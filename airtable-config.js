// üåê CONFIGURACI√ìN CORREGIDA DE AIRTABLE - VERSI√ìN CON DETECCI√ìN AUTOM√ÅTICA
// airtable-config.js - Soluci√≥n Error 404

class AirtableAPI {
    constructor() {
        this.baseUrl = '/.netlify/functions/airtable-proxy';
        this.debugMode = true;
        this.connectionStatus = 'disconnected';
        this.lastError = null;
        this.requestCount = 0;
        this.isConnected = false;
        
        // üîß MAPEO DE TABLAS CON DETECCI√ìN AUTOM√ÅTICA
        this.tables = {
            solicitudes: 'Solicitudes',
            tecnicos: 'Tecnicos', 
            usuarios: 'Usuarios',
            solicitudesAcceso: 'SolicitudesAcceso' // POSIBLE CAUSA DEL ERROR 404
        };

        // üîç Variaciones comunes de nombres de tablas para auto-detecci√≥n
        this.tableVariations = {
            solicitudesAcceso: [
                'SolicitudesAcceso',
                'Solicitudes_Acceso', 
                'solicitudes_acceso',
                'solicitudesacceso',
                'SolicitudAcceso',
                'AccessRequests',
                'access_requests',
                'Solicitudes de Acceso'
            ],
            solicitudes: [
                'Solicitudes',
                'solicitudes',
                'Requests',
                'requests'
            ],
            tecnicos: [
                'Tecnicos',
                'tecnicos',
                'Technicians', 
                'technicians',
                'Personal'
            ],
            usuarios: [
                'Usuarios',
                'usuarios',
                'Users',
                'users'
            ]
        };

        // Auto-detecci√≥n al inicializar
        this.autoDetectTables();

        console.log('üöÄ AirtableAPI CORREGIDO iniciado con auto-detecci√≥n de tablas');
    }

    // üîç AUTO-DETECCI√ìN DE TABLAS CORREGIDA
    async autoDetectTables() {
        console.log('üîç Iniciando auto-detecci√≥n de tablas...');
        
        try {
            // Esperar un poco para que las funciones est√©n listas
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const corrections = {};
            
            for (const [tableKey, variations] of Object.entries(this.tableVariations)) {
                console.log(`üîç Detectando tabla para: ${tableKey}`);
                
                for (const variation of variations) {
                    try {
                        const response = await fetch(`${this.baseUrl}/${encodeURIComponent(variation)}?maxRecords=1`);
                        
                        if (response.ok) {
                            console.log(`‚úÖ Tabla encontrada: ${tableKey} -> ${variation}`);
                            corrections[tableKey] = variation;
                            break;
                        }
                    } catch (error) {
                        // Continuar con la siguiente variaci√≥n
                    }
                }
                
                if (!corrections[tableKey]) {
                    console.warn(`‚ö†Ô∏è No se encontr√≥ tabla para: ${tableKey}`);
                }
            }
            
            // Aplicar correcciones
            Object.assign(this.tables, corrections);
            
            console.log('üéØ Tablas auto-detectadas:', this.tables);
            
            // Guardar configuraci√≥n para debug
            if (typeof window !== 'undefined') {
                window.airtableTableMapping = this.tables;
            }
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Auto-detecci√≥n fall√≥, usando nombres por defecto:', error.message);
        }
    }

    // üìä M√âTODO GETSTATUS CORREGIDO
    getStatus() {
        return {
            isConnected: this.isConnected,
            connectionStatus: this.connectionStatus,
            lastError: this.lastError,
            requestCount: this.requestCount,
            tableMapping: this.tables,
            timestamp: new Date().toISOString()
        };
    }

    // üìù Logging mejorado
    log(message, data = null) {
        if (!this.debugMode) return;
        
        const timestamp = new Date().toLocaleTimeString('es-CO');
        console.log(`[${timestamp}] AirtableAPI: ${message}`, data || '');
        
        // Event para logging externo
        if (typeof window !== 'undefined' && window.dispatchEvent) {
            try {
                window.dispatchEvent(new CustomEvent('airtable-log', {
                    detail: { message, data, timestamp: new Date().toISOString() }
                }));
            } catch (e) {
                // Ignorar errores de eventos
            }
        }
    }

    // üîó FUNCI√ìN BASE CORREGIDA CON MEJOR MANEJO DE ERRORES
    async makeRequest(endpoint, method = 'GET', data = null) {
        this.requestCount++;
        
        try {
            const url = `${this.baseUrl}/${endpoint}`;
            this.log(`üì° ${method} ${url}`);

            const options = {
                method,
                headers: {
                    'Content-Type': 'application/json'
                }
            };

            if (data && (method === 'POST' || method === 'PATCH')) {
                options.body = JSON.stringify(data);
                this.log('üìù Data enviada:', data);
            }

            const response = await fetch(url, options);
            const responseText = await response.text();
            
            this.log('üì® Response status:', response.status);

            if (!response.ok) {
                let errorData;
                try {
                    errorData = JSON.parse(responseText);
                } catch (e) {
                    errorData = { message: responseText };
                }
                
                this.lastError = {
                    status: response.status,
                    error: errorData,
                    url,
                    method,
                    endpoint,
                    timestamp: new Date().toISOString()
                };
                
                this.connectionStatus = 'error';
                this.isConnected = false;
                
                // üîß MANEJO ESPECIAL PARA ERROR 404 DE TABLAS
                if (response.status === 404 && endpoint.includes('/')) {
                    const tableName = endpoint.split('?')[0]; // Remover query params
                    console.error(`‚ùå ERROR 404: Tabla "${tableName}" no encontrada`);
                    console.log('üí° Tablas disponibles:', this.tables);
                    console.log('üîç Iniciando re-detecci√≥n autom√°tica...');
                    
                    // Intentar re-detectar tablas
                    await this.autoDetectTables();
                    
                    throw new Error(`Tabla "${tableName}" no encontrada. Verifica que exista en Airtable. Mapeo actual: ${JSON.stringify(this.tables)}`);
                }
                
                throw new Error(errorData.message || `Error ${response.status}: ${errorData.error || 'Error desconocido'}`);
            }

            const responseData = JSON.parse(responseText);
            this.connectionStatus = 'connected';
            this.isConnected = true;
            
            return responseData;

        } catch (error) {
            this.connectionStatus = 'error';
            this.isConnected = false;
            this.lastError = {
                error: error.message,
                timestamp: new Date().toISOString(),
                endpoint: endpoint
            };
            
            this.log(`‚ùå Error en makeRequest para "${endpoint}": ${error.message}`);
            throw error;
        }
    }

    // ‚úÖ TEST DE CONEXI√ìN MEJORADO
    async testConnection() {
        this.log('üß™ Iniciando test de conexi√≥n...');
        
        try {
            // Test funciones Netlify primero
            const helloResponse = await fetch('/.netlify/functions/hello');
            if (!helloResponse.ok) {
                throw new Error(`Funciones Netlify no disponibles: ${helloResponse.status}`);
            }
            
            this.log('‚úÖ Funciones Netlify operativas');
            
            // Test cada tabla para verificar existencia
            for (const [tableKey, tableName] of Object.entries(this.tables)) {
                try {
                    await this.makeRequest(tableName + '?maxRecords=1');
                    this.log(`‚úÖ Tabla ${tableKey} (${tableName}) accesible`);
                } catch (error) {
                    this.log(`‚ö†Ô∏è Tabla ${tableKey} (${tableName}) no accesible: ${error.message}`);
                }
            }
            
            this.isConnected = true;
            this.connectionStatus = 'connected';
            this.log('‚úÖ Test de conexi√≥n completado');
            
            return true;
            
        } catch (error) {
            this.isConnected = false;
            this.connectionStatus = 'error';
            this.log(`‚ùå Test de conexi√≥n fall√≥: ${error.message}`);
            return false;
        }
    }

    // üìã CREAR SOLICITUD DE ACCESO CORREGIDA
    async createSolicitudAcceso(solicitudData) {
        try {
            this.log('üìã Creando solicitud de acceso...');
            
            const data = {
                fields: solicitudData
            };
            
            // üîß USAR TABLA AUTO-DETECTADA
            const tableName = this.tables.solicitudesAcceso;
            this.log(`üìä Usando tabla: ${tableName}`);
            
            const result = await this.makeRequest(tableName, 'POST', data);
            
            this.log('‚úÖ Solicitud de acceso creada exitosamente');
            
            return {
                id: result.id,
                ...result.fields
            };
            
        } catch (error) {
            this.log(`‚ùå Error creando solicitud de acceso: ${error.message}`);
            
            // üîß SUGERENCIA AUTOM√ÅTICA SI FALLA
            if (error.message.includes('404') || error.message.includes('not found')) {
                const suggestion = `
‚ùå TABLA DE SOLICITUDES DE ACCESO NO ENCONTRADA

üîç Posibles soluciones:
1. Verificar que existe la tabla en Airtable
2. Crear tabla "SolicitudesAcceso" con estos campos:
   ‚Ä¢ nombreCompleto (Single line text)
   ‚Ä¢ email (Email)
   ‚Ä¢ telefono (Phone number)
   ‚Ä¢ servicioHospitalario (Single select)
   ‚Ä¢ cargo (Single select)
   ‚Ä¢ justificacion (Long text)
   ‚Ä¢ estado (Single select: PENDIENTE, APROBADA, RECHAZADA)
   ‚Ä¢ fechaSolicitud (Date)

üéØ Tablas encontradas: ${JSON.stringify(this.tables, null, 2)}

üí° Usa la herramienta de diagn√≥stico para m√°s detalles.
                `;
                console.error(suggestion);
            }
            
            throw error;
        }
    }

    // üîÑ ACTUALIZAR SOLICITUD DE ACCESO CORREGIDA
    async updateSolicitudAcceso(solicitudId, updateData) {
        try {
            this.log(`üîÑ Actualizando solicitud de acceso: ${solicitudId}`);
            
            if (!solicitudId) {
                throw new Error('ID de solicitud requerido');
            }
            
            // üîß USAR TABLA AUTO-DETECTADA
            const tableName = this.tables.solicitudesAcceso;
            this.log(`üìä Usando tabla: ${tableName}`);
            
            const result = await this.makeRequest(
                `${tableName}/${solicitudId}`, 
                'PATCH', 
                { fields: updateData }
            );
            
            this.log('‚úÖ Solicitud de acceso actualizada exitosamente');
            
            return {
                id: result.id,
                ...result.fields
            };
            
        } catch (error) {
            this.log(`‚ùå Error actualizando solicitud de acceso: ${error.message}`);
            throw error;
        }
    }

    // üìã OBTENER SOLICITUDES DE ACCESO CORREGIDA
    async getSolicitudesAcceso() {
        try {
            this.log('üìã Obteniendo solicitudes de acceso...');
            
            // üîß USAR TABLA AUTO-DETECTADA
            const tableName = this.tables.solicitudesAcceso;
            this.log(`üìä Usando tabla: ${tableName}`);
            
            const result = await this.makeRequest(tableName);
            
            const solicitudes = result.records.map(record => ({
                id: record.id,
                ...record.fields
            }));
            
            this.log(`‚úÖ ${solicitudes.length} solicitudes de acceso obtenidas`);
            return solicitudes;
            
        } catch (error) {
            this.log(`‚ùå Error obteniendo solicitudes de acceso: ${error.message}`);
            
            // üîß RETORNO SEGURO EN CASO DE ERROR
            if (error.message.includes('404')) {
                console.warn('‚ö†Ô∏è Tabla de solicitudes de acceso no encontrada, retornando array vac√≠o');
                return [];
            }
            
            throw error;
        }
    }

    // üî¢ Generar n√∫mero de solicitud por √°rea
    async generateSolicitudNumber(area) {
        try {
            this.log(`üî¢ Generando n√∫mero para √°rea: ${area}`);
            
            const solicitudes = await this.getSolicitudes();
            
            const prefijos = {
                'INGENIERIA_BIOMEDICA': 'SOLBIO',
                'MECANICA': 'SOLMEC', 
                'INFRAESTRUCTURA': 'SOLINFRA'
            };
            
            const prefijo = prefijos[area];
            if (!prefijo) {
                this.log(`‚ö†Ô∏è √Årea no reconocida: ${area}, usando SOL gen√©rico`);
                return `SOL${Date.now()}`;
            }
            
            const solicitudesArea = solicitudes.filter(s => 
                s.numero && s.numero.startsWith(prefijo)
            );
            
            let maxNumber = 0;
            
            solicitudesArea.forEach(solicitud => {
                const numeroStr = solicitud.numero.replace(prefijo, '');
                const numero = parseInt(numeroStr);
                if (!isNaN(numero) && numero > maxNumber) {
                    maxNumber = numero;
                }
            });
            
            const siguienteNumero = maxNumber + 1;
            const numeroFormateado = siguienteNumero.toString().padStart(5, '0');
            const numeroCompleto = `${prefijo}${numeroFormateado}`;
            
            this.log(`‚úÖ N√∫mero generado: ${numeroCompleto}`);
            return numeroCompleto;
            
        } catch (error) {
            this.log(`‚ùå Error generando n√∫mero: ${error.message}`);
            const timestamp = Date.now().toString().slice(-5);
            return `SOL${timestamp}`;
        }
    }

    // ‚è∞ Calcular fecha l√≠mite seg√∫n prioridad
    calcularFechaLimite(prioridad) {
        const ahora = new Date();
        let horasLimite;
        
        switch (prioridad) {
            case 'CRITICA':
                horasLimite = 2;
                break;
            case 'ALTA':
                horasLimite = 8;
                break;
            case 'MEDIA':
                horasLimite = 24;
                break;
            case 'BAJA':
                horasLimite = 72;
                break;
            default:
                horasLimite = 24;
        }
        
        const fechaLimite = new Date(ahora.getTime() + (horasLimite * 60 * 60 * 1000));
        return fechaLimite.toISOString();
    }

    // üìã Crear solicitud con numeraci√≥n autom√°tica
    async createSolicitud(solicitudData) {
        try {
            this.log('üìã Creando solicitud con numeraci√≥n autom√°tica...');
            
            const numeroSolicitud = await this.generateSolicitudNumber(solicitudData.servicioIngenieria);
            
            const data = {
                fields: {
                    numero: numeroSolicitud,
                    servicioIngenieria: solicitudData.servicioIngenieria,
                    tipoServicio: solicitudData.tipoServicio || 'MANTENIMIENTO_PREVENTIVO',
                    prioridad: solicitudData.prioridad || 'MEDIA',
                    equipo: solicitudData.equipo || 'Equipo no especificado',
                    ubicacion: solicitudData.ubicacion || 'Ubicaci√≥n no especificada',
                    descripcion: solicitudData.descripcion || 'Descripci√≥n no especificada',
                    observaciones: solicitudData.observaciones || '',
                    
                    // Datos del solicitante
                    solicitante: solicitudData.solicitante || 'Usuario sistema',
                    servicioHospitalario: solicitudData.servicioHospitalario || 'NO_ESPECIFICADO',
                    emailSolicitante: solicitudData.emailSolicitante || '',
                    
                    // Datos de gesti√≥n
                    estado: 'PENDIENTE',
                    fechaCreacion: new Date().toISOString(),
                    fechaLimiteRespuesta: this.calcularFechaLimite(solicitudData.prioridad),
                    
                    // Campos de asignaci√≥n
                    tecnicoAsignado: '',
                    fechaAsignacion: '',
                    fechaInicio: '',
                    fechaCompletado: '',
                    
                    // Campos de tiempo
                    tiempoRespuestaHoras: 0,
                    tiempoResolucionHoras: 0,
                    estadoTiempo: 'EN_TIEMPO'
                }
            };
            
            const result = await this.makeRequest(this.tables.solicitudes, 'POST', data);
            
            this.log(`‚úÖ Solicitud creada con n√∫mero: ${numeroSolicitud}`);
            
            return {
                success: true,
                id: result.id,
                numero: numeroSolicitud,
                ...result.fields
            };
            
        } catch (error) {
            this.log(`‚ùå Error creando solicitud: ${error.message}`);
            return {
                success: false,
                error: error.message
            };
        }
    }

    // üìã Obtener solicitudes
    async getSolicitudes() {
        try {
            const result = await this.makeRequest(this.tables.solicitudes);
            
            const solicitudes = result.records.map(record => ({
                id: record.id,
                ...record.fields
            }));
            
            this.log(`‚úÖ ${solicitudes.length} solicitudes obtenidas`);
            return solicitudes;
            
        } catch (error) {
            this.log(`‚ùå Error obteniendo solicitudes: ${error.message}`);
            return [];
        }
    }

    // üë®‚Äçüîß Obtener t√©cnicos
    async getTecnicos() {
        try {
            const result = await this.makeRequest(this.tables.tecnicos);
            
            const tecnicos = result.records.map(record => ({
                id: record.id,
                ...record.fields
            }));
            
            this.log(`‚úÖ ${tecnicos.length} t√©cnicos obtenidos`);
            return tecnicos;
            
        } catch (error) {
            this.log(`‚ùå Error obteniendo t√©cnicos: ${error.message}`);
            return [];
        }
    }

    // üîÑ Actualizar t√©cnico
    async updateTecnico(tecnicoId, updateData) {
        try {
            const result = await this.makeRequest(
                `${this.tables.tecnicos}/${tecnicoId}`, 
                'PATCH', 
                { fields: updateData }
            );
            
            return {
                id: result.id,
                ...result.fields
            };
            
        } catch (error) {
            this.log(`‚ùå Error actualizando t√©cnico: ${error.message}`);
            throw error;
        }
    }

    // üéØ Asignar t√©cnico con gesti√≥n de tiempos
    async asignarTecnicoConTiempos(solicitudId, tecnicoId, observacionesAsignacion = '') {
        try {
            this.log('üéØ Asignando t√©cnico con gesti√≥n de tiempos...');
            
            // Obtener datos
            const solicitudes = await this.getSolicitudes();
            const solicitud = solicitudes.find(s => s.id === solicitudId);
            
            if (!solicitud) {
                throw new Error('Solicitud no encontrada');
            }
            
            const tecnicos = await this.getTecnicos();
            const tecnico = tecnicos.find(t => t.id === tecnicoId);
            
            if (!tecnico) {
                throw new Error('T√©cnico no encontrado');
            }
            
            if (tecnico.estado !== 'disponible') {
                throw new Error(`T√©cnico no disponible. Estado actual: ${tecnico.estado}`);
            }
            
            // Calcular tiempo de respuesta
            const ahora = new Date();
            const fechaCreacion = new Date(solicitud.fechaCreacion);
            const tiempoRespuestaMs = ahora.getTime() - fechaCreacion.getTime();
            const tiempoRespuestaHoras = Math.round((tiempoRespuestaMs / (1000 * 60 * 60)) * 100) / 100;
            
            // Determinar estado del tiempo
            const fechaLimite = new Date(solicitud.fechaLimiteRespuesta);
            const estadoTiempo = ahora <= fechaLimite ? 'EN_TIEMPO' : 'FUERA_TIEMPO';
            
            // Actualizar solicitud
            const solicitudUpdate = {
                estado: 'ASIGNADA',
                tecnicoAsignado: tecnico.nombre,
                tecnicoAsignadoId: tecnicoId,
                fechaAsignacion: ahora.toISOString(),
                tiempoRespuestaHoras: tiempoRespuestaHoras,
                estadoTiempo: estadoTiempo,
                observacionesAsignacion: observacionesAsignacion
            };
            
            await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
                fields: solicitudUpdate
            });
            
            // Actualizar estado del t√©cnico
            await this.updateTecnico(tecnicoId, { 
                estado: 'ocupado',
                ultimaAsignacion: ahora.toISOString(),
                solicitudActual: solicitudId
            });
            
            this.log('‚úÖ Asignaci√≥n completada exitosamente');
            
            return {
                success: true,
                solicitud: {
                    id: solicitudId,
                    numero: solicitud.numero,
                    estado: 'ASIGNADA',
                    tecnicoAsignado: tecnico.nombre,
                    fechaAsignacion: ahora.toISOString(),
                    tiempoRespuestaHoras: tiempoRespuestaHoras,
                    estadoTiempo: estadoTiempo
                },
                tecnico: {
                    id: tecnicoId,
                    nombre: tecnico.nombre,
                    area: tecnico.area,
                    estadoAnterior: tecnico.estado,
                    estadoNuevo: 'ocupado'
                },
                tiempos: {
                    fechaCreacion: solicitud.fechaCreacion,
                    fechaAsignacion: ahora.toISOString(),
                    fechaLimite: solicitud.fechaLimiteRespuesta,
                    tiempoRespuestaHoras: tiempoRespuestaHoras,
                    estadoTiempo: estadoTiempo
                }
            };
            
        } catch (error) {
            this.log(`‚ùå Error en asignaci√≥n: ${error.message}`);
            throw error;
        }
    }

    // ‚úÖ Completar solicitud
    async completarSolicitud(solicitudId, observacionesCompletado = '', requiereAprobacion = false) {
        try {
            this.log('‚úÖ Completando solicitud...');
            
            const solicitudes = await this.getSolicitudes();
            const solicitud = solicitudes.find(s => s.id === solicitudId);
            
            if (!solicitud) {
                throw new Error('Solicitud no encontrada');
            }
            
            if (solicitud.estado !== 'ASIGNADA' && solicitud.estado !== 'EN_PROCESO') {
                throw new Error(`No se puede completar solicitud en estado: ${solicitud.estado}`);
            }
            
            // Calcular tiempos
            const ahora = new Date();
            const fechaCreacion = new Date(solicitud.fechaCreacion);
            const fechaAsignacion = solicitud.fechaAsignacion ? new Date(solicitud.fechaAsignacion) : fechaCreacion;
            
            const tiempoResolucionMs = ahora.getTime() - fechaAsignacion.getTime();
            const tiempoResolucionHoras = Math.round((tiempoResolucionMs / (1000 * 60 * 60)) * 100) / 100;
            
            const tiempoTotalMs = ahora.getTime() - fechaCreacion.getTime();
            const tiempoTotalHoras = Math.round((tiempoTotalMs / (1000 * 60 * 60)) * 100) / 100;
            
            // Actualizar solicitud
            const estadoFinal = requiereAprobacion ? 'PENDIENTE_APROBACION' : 'COMPLETADA';
            
            const solicitudUpdate = {
                estado: estadoFinal,
                fechaCompletado: ahora.toISOString(),
                tiempoResolucionHoras: tiempoResolucionHoras,
                tiempoTotalHoras: tiempoTotalHoras,
                observacionesCompletado: observacionesCompletado,
                requiereAprobacion: requiereAprobacion
            };
            
            await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
                fields: solicitudUpdate
            });
            
            // Liberar t√©cnico si est√° completada
            if (!requiereAprobacion && solicitud.tecnicoAsignadoId) {
                await this.updateTecnico(solicitud.tecnicoAsignadoId, { 
                    estado: 'disponible',
                    solicitudActual: '',
                    ultimaCompletada: ahora.toISOString()
                });
            }
            
            this.log('‚úÖ Solicitud completada exitosamente');
            
            return {
                success: true,
                solicitud: {
                    id: solicitudId,
                    numero: solicitud.numero,
                    estado: estadoFinal,
                    fechaCompletado: ahora.toISOString(),
                    tiempoResolucionHoras: tiempoResolucionHoras,
                    tiempoTotalHoras: tiempoTotalHoras
                },
                tiempos: {
                    fechaCreacion: solicitud.fechaCreacion,
                    fechaAsignacion: solicitud.fechaAsignacion,
                    fechaCompletado: ahora.toISOString(),
                    tiempoResolucionHoras: tiempoResolucionHoras,
                    tiempoTotalHoras: tiempoTotalHoras
                }
            };
            
        } catch (error) {
            this.log(`‚ùå Error completando solicitud: ${error.message}`);
            throw error;
        }
    }

    // ü§ñ Auto-asignaci√≥n inteligente
    async autoAsignarSolicitudesPendientes() {
        try {
            this.log('ü§ñ Iniciando auto-asignaci√≥n...');
            
            const solicitudes = await this.getSolicitudes();
            const solicitudesPendientes = solicitudes.filter(s => s.estado === 'PENDIENTE');
            
            if (solicitudesPendientes.length === 0) {
                return {
                    success: true,
                    message: 'No hay solicitudes pendientes para asignar',
                    asignaciones: 0
                };
            }
            
            const tecnicos = await this.getTecnicos();
            const tecnicosDisponibles = tecnicos.filter(t => t.estado === 'disponible');
            
            if (tecnicosDisponibles.length === 0) {
                return {
                    success: false,
                    message: 'No hay t√©cnicos disponibles para asignaci√≥n',
                    asignaciones: 0
                };
            }
            
            const resultados = [];
            
            // Asignar por prioridad
            const solicitudesOrdenadas = solicitudesPendientes.sort((a, b) => {
                const prioridades = { 'CRITICA': 4, 'ALTA': 3, 'MEDIA': 2, 'BAJA': 1 };
                return (prioridades[b.prioridad] || 0) - (prioridades[a.prioridad] || 0);
            });
            
            for (const solicitud of solicitudesOrdenadas) {
                try {
                    // Buscar t√©cnico del √°rea correspondiente
                    let tecnicoSeleccionado = tecnicosDisponibles.find(t => 
                        t.area === solicitud.servicioIngenieria && t.estado === 'disponible'
                    );
                    
                    // Si no hay t√©cnico del √°rea, buscar cualquier disponible
                    if (!tecnicoSeleccionado) {
                        tecnicoSeleccionado = tecnicosDisponibles.find(t => t.estado === 'disponible');
                    }
                    
                    if (tecnicoSeleccionado) {
                        const resultado = await this.asignarTecnicoConTiempos(
                            solicitud.id, 
                            tecnicoSeleccionado.id,
                            'Asignaci√≥n autom√°tica del sistema'
                        );
                        
                        if (resultado.success) {
                            resultados.push({
                                solicitud: solicitud.numero,
                                tecnico: tecnicoSeleccionado.nombre,
                                area: solicitud.servicioIngenieria,
                                prioridad: solicitud.prioridad,
                                compatibilidad: tecnicoSeleccionado.area === solicitud.servicioIngenieria ? 'AREA_EXACTA' : 'AREA_DIFERENTE'
                            });
                            
                            // Marcar t√©cnico como ocupado
                            tecnicoSeleccionado.estado = 'ocupado';
                        }
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Error asignando solicitud ${solicitud.numero}: ${error.message}`);
                }
            }
            
            this.log(`‚úÖ Auto-asignaci√≥n completada: ${resultados.length} asignaciones`);
            
            return {
                success: true,
                message: `Se asignaron ${resultados.length} solicitudes autom√°ticamente`,
                asignaciones: resultados.length,
                detalles: resultados,
                solicitudesPendientes: solicitudesPendientes.length,
                tecnicosDisponibles: tecnicosDisponibles.length,
                timestamp: new Date().toISOString()
            };
            
        } catch (error) {
            this.log(`‚ùå Error en auto-asignaci√≥n: ${error.message}`);
            return {
                success: false,
                error: error.message,
                asignaciones: 0
            };
        }
    }

    // üë§ Obtener usuarios
    async getUsuarios() {
        try {
            const result = await this.makeRequest(this.tables.usuarios);
            
            const usuarios = result.records.map(record => ({
                id: record.id,
                ...record.fields
            }));
            
            this.log(`‚úÖ ${usuarios.length} usuarios obtenidos`);
            return usuarios;
            
        } catch (error) {
            this.log(`‚ùå Error obteniendo usuarios: ${error.message}`);
            return [];
        }
    }

    // ‚ûï Crear usuario
    async createUsuario(userData) {
        try {
            const data = {
                fields: userData
            };
            
            const result = await this.makeRequest(this.tables.usuarios, 'POST', data);
            
            return {
                id: result.id,
                ...result.fields
            };
            
        } catch (error) {
            this.log(`‚ùå Error creando usuario: ${error.message}`);
            throw error;
        }
    }

    // üîÑ Actualizar usuario
    async updateUsuario(userId, updateData) {
        try {
            const result = await this.makeRequest(
                `${this.tables.usuarios}/${userId}`, 
                'PATCH', 
                { fields: updateData }
            );
            
            return {
                id: result.id,
                ...result.fields
            };
            
        } catch (error) {
            this.log(`‚ùå Error actualizando usuario: ${error.message}`);
            throw error;
        }
    }

    // ‚úÖ Validar credenciales de usuario
    async validateUserCredentials(email, codigoAcceso) {
        try {
            const usuarios = await this.getUsuarios();
            
            const usuario = usuarios.find(u => 
                u.email && u.email.toLowerCase() === email.toLowerCase()
            );

            if (!usuario) {
                return {
                    valid: false,
                    error: 'Usuario no encontrado con ese email'
                };
            }

            if (usuario.estado !== 'ACTIVO') {
                return {
                    valid: false,
                    error: 'Usuario inactivo. Contacte al administrador.'
                };
            }

            if (usuario.codigoAcceso !== codigoAcceso) {
                return {
                    valid: false,
                    error: 'C√≥digo de acceso incorrecto'
                };
            }

            return {
                valid: true,
                user: usuario
            };
            
        } catch (error) {
            this.log(`‚ùå Error validando credenciales: ${error.message}`);
            return {
                valid: false,
                error: 'Error interno del sistema'
            };
        }
    }

    // üìä Obtener estad√≠sticas de tiempos
    async getEstadisticasTiempos() {
        try {
            this.log('üìä Calculando estad√≠sticas de tiempos...');
            
            const solicitudes = await this.getSolicitudes();
            const ahora = new Date();
            
            const stats = {
                total: solicitudes.length,
                pendientes: solicitudes.filter(s => s.estado === 'PENDIENTE').length,
                asignadas: solicitudes.filter(s => s.estado === 'ASIGNADA').length,
                completadas: solicitudes.filter(s => s.estado === 'COMPLETADA').length,
                tiemposRespuesta: {
                    promedio: 0,
                    enTiempo: 0,
                    fueraTiempo: 0,
                    porcentajeEnTiempo: 0
                },
                timestamp: ahora.toISOString()
            };
            
            // Calcular estad√≠sticas de tiempo
            const solicitudesConTiempo = solicitudes.filter(s => s.tiempoRespuestaHoras);
            
            if (solicitudesConTiempo.length > 0) {
                const tiemposRespuesta = solicitudesConTiempo.map(s => s.tiempoRespuestaHoras);
                stats.tiemposRespuesta.promedio = tiemposRespuesta.reduce((a, b) => a + b, 0) / tiemposRespuesta.length;
                stats.tiemposRespuesta.enTiempo = solicitudes.filter(s => s.estadoTiempo === 'EN_TIEMPO').length;
                stats.tiemposRespuesta.fueraTiempo = solicitudes.filter(s => s.estadoTiempo === 'FUERA_TIEMPO').length;
                stats.tiemposRespuesta.porcentajeEnTiempo = Math.round((stats.tiemposRespuesta.enTiempo / solicitudesConTiempo.length) * 100);
            }
            
            this.log('‚úÖ Estad√≠sticas calculadas');
            return stats;
            
        } catch (error) {
            this.log(`‚ùå Error calculando estad√≠sticas: ${error.message}`);
            return {
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }

    // üìä Estad√≠sticas del sistema (alias para compatibilidad)
    getSystemStats() {
        return this.getStatus();
    }
}

// üöÄ Inicializar API Global
window.airtableAPI = new AirtableAPI();

// üëÇ Event listener para logs
if (typeof window !== 'undefined') {
    window.addEventListener('airtable-log', function(event) {
        const logElement = document.getElementById('diagnostic-log');
        if (logElement) {
            const { message, timestamp } = event.detail;
            const time = new Date(timestamp).toLocaleTimeString('es-CO');
            logElement.textContent += `[${time}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }
    });
}

console.log('‚úÖ AirtableAPI CORREGIDO iniciado con auto-detecci√≥n de tablas y manejo de errores 404');
console.log('üîç M√©todos disponibles:', Object.getOwnPropertyNames(AirtableAPI.prototype).filter(name => name !== 'constructor'));
console.log('üìä Estado inicial:', window.airtableAPI.getStatus());