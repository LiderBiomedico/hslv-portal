// üõ°Ô∏è Configuraci√≥n COMPLETA de Airtable API - Con cambio de tipo de servicio al completar
// airtable-config.js - Versi√≥n con actualizaci√≥n de tipo de servicio

console.log('üöÄ Cargando airtable-config.js (VERSI√ìN CON CAMBIO DE TIPO DE SERVICIO)...');

// üó∫Ô∏è MAPEO DE VALORES CORREGIDO PARA COMPATIBILIDAD CON AIRTABLE
const AIRTABLE_VALUE_MAPPING = {
    servicioIngenieria: {
        'INGENIERIA_BIOMEDICA': 'INGENIERIA_BIOMEDICA',
        'Ingenier√≠a Biom√©dica': 'INGENIERIA_BIOMEDICA',
        'Ingenieria Biomedica': 'INGENIERIA_BIOMEDICA',
        'Ing. Biom√©dica': 'INGENIERIA_BIOMEDICA',
        'BIOMEDICA': 'INGENIERIA_BIOMEDICA',
        'MECANICA': 'MECANICA',
        'Mec√°nica': 'MECANICA',
        'Mecanica': 'MECANICA',
        'INFRAESTRUCTURA': 'INFRAESTRUCTURA',
        'Infraestructura': 'INFRAESTRUCTURA'
    },
    tipoServicio: {
        'MANTENIMIENTO_PREVENTIVO': 'MANTENIMIENTO_PREVENTIVO',
        'Mantenimiento Preventivo': 'MANTENIMIENTO_PREVENTIVO',
        'MANTENIMIENTO_CORRECTIVO': 'MANTENIMIENTO_CORRECTIVO',
        'Mantenimiento Correctivo': 'MANTENIMIENTO_CORRECTIVO',
        'REPARACION': 'REPARACION',
        'Reparaci√≥n': 'REPARACION',
        'INSTALACION': 'INSTALACION',
        'Instalaci√≥n': 'INSTALACION',
        'DESINSTALACION': 'DESINSTALACION',
        'Desinstalaci√≥n': 'DESINSTALACION',
        'CALIBRACION': 'CALIBRACION',
        'Calibraci√≥n': 'CALIBRACION',
        'INSPECCION': 'INSPECCION',
        'Inspecci√≥n': 'INSPECCION',
        'ACTUALIZACION': 'ACTUALIZACION',
        'Actualizaci√≥n': 'ACTUALIZACION',
        'EMERGENCIA': 'EMERGENCIA',
        'Emergencia': 'EMERGENCIA',
        'ERROR_USUARIO': 'ERROR_USUARIO',
        'Error de Usuario': 'ERROR_USUARIO'
    },
    prioridad: {
        'CRITICA': 'CRITICA',
        'Cr√≠tica': 'CRITICA',
        'ALTA': 'ALTA',
        'Alta': 'ALTA',
        'MEDIA': 'MEDIA',
        'Media': 'MEDIA',
        'BAJA': 'BAJA',
        'Baja': 'BAJA'
    },
    estado: {
        'PENDIENTE': 'PENDIENTE',
        'Pendiente': 'PENDIENTE',
        'ASIGNADA': 'ASIGNADA',
        'Asignada': 'ASIGNADA',
        'EN_PROCESO': 'EN_PROCESO',
        'En Proceso': 'EN_PROCESO',
        'EN PROCESO': 'EN_PROCESO',
        'COMPLETADA': 'COMPLETADA',
        'Completada': 'COMPLETADA',
        'CANCELADA': 'CANCELADA',
        'Cancelada': 'CANCELADA'
    },
    area: {
        'INGENIERIA_BIOMEDICA': 'INGENIERIA_BIOMEDICA',
        'Ingenier√≠a Biom√©dica': 'INGENIERIA_BIOMEDICA',
        'Ingenieria Biomedica': 'INGENIERIA_BIOMEDICA',
        'Ing. Biom√©dica': 'INGENIERIA_BIOMEDICA',
        'BIOMEDICA': 'INGENIERIA_BIOMEDICA',
        'MECANICA': 'MECANICA',
        'Mec√°nica': 'MECANICA',
        'Mecanica': 'MECANICA',
        'INFRAESTRUCTURA': 'INFRAESTRUCTURA',
        'Infraestructura': 'INFRAESTRUCTURA'
    },
    estadoSolicitudAcceso: {
        'PENDIENTE': 'Pendiente',
        'APROBADA': 'Aprobada',
        'RECHAZADA': 'Rechazada'
    },
    estadoUsuario: {
        'ACTIVO': 'Activo',
        'INACTIVO': 'Inactivo',
        'SUSPENDIDO': 'Suspendido'
    }
};

// üìã Campos seguros confirmados para cada tabla
const SAFE_FIELDS = {
    solicitudes: [
        'numero',
        'descripcion', 
        'estado',
        'fechaCreacion',
        'servicioIngenieria',
        'tipoServicio',
        'prioridad',
        'equipo',
        'ubicacion',
        'observaciones',
        'solicitante',
        'servicioHospitalario',
        'emailSolicitante',
        'tecnicoAsignado',
        'fechaAsignacion',
        'observacionesAsignacion',
        'tiempoRespuestaMaximo',
        'fechaInicioTrabajo',
        'fechaCompletado',
        'tiempoTotalRespuesta'
    ],
    tecnicos: [
        'nombre',
        'email',
        'area',
        'tipo',
        'especialidad',
        'estado',
        'fechaCreacion',
        'solicitudAsignada'
    ],
    solicitudesAcceso: [
        'nombreCompleto',
        'email',
        'telefono',
        'servicioHospitalario',
        'cargo',
        'justificacion',
        'fechaSolicitud',
        'estado',
        'esUrgente',
        'usuarioCreado'
    ],
    usuarios: [
        'nombreCompleto',
        'email',
        'servicioHospitalario',
        'cargo',
        'codigoAcceso',
        'estado',
        'fechaCreacion',
        'solicitudOrigenId'
    ]
};

class AirtableAPI {
    constructor() {
        console.log('üîß Inicializando AirtableAPI con cambio de tipo de servicio...');
        
        this.hostname = window.location.hostname;
        this.isLocalDevelopment = this.hostname === 'localhost' || 
                                 this.hostname === '127.0.0.1' ||
                                 this.hostname.startsWith('localhost:') ||
                                 this.hostname.startsWith('127.0.0.1:');
        
        console.log('üîç Hostname:', this.hostname);
        console.log('üè† Es desarrollo local:', this.isLocalDevelopment);
        
        if (this.isLocalDevelopment) {
            this.useProxy = false;
            this.baseUrl = 'https://api.airtable.com/v0/appFyEBCedQGOeJyV';
            this.directApiKey = 'patev8QTzDMA5EGSK.777efed543e6fac49d2c830659a6d0c508b617ff90c352921d626fd9c929e570';
            console.log('üîß MODO DESARROLLO: Conexi√≥n directa');
        } else {
            this.useProxy = true;
            this.baseUrl = '/.netlify/functions/airtable-proxy';
            this.directApiKey = null;
            console.log('üõ°Ô∏è MODO PRODUCCI√ìN: Usando proxy Netlify');
        }
        
        // üìã Tablas confirmadas
        this.tables = {
            solicitudes: 'Solicitudes',
            tecnicos: 'Tecnicos', 
            usuarios: 'Usuarios',
            solicitudesAcceso: 'SolicitudesAcceso'
        };

        // üó∫Ô∏è Mapeo de valores actualizado
        this.fieldMappings = AIRTABLE_VALUE_MAPPING;

        // üî¢ CONTADORES PARA NUMERACI√ìN ESPEC√çFICA
        this.areaCounters = {
            'INGENIERIA_BIOMEDICA': 0,
            'MECANICA': 0,
            'INFRAESTRUCTURA': 0
        };

        // üéØ PREFIJOS POR √ÅREA
        this.areaPrefixes = {
            'INGENIERIA_BIOMEDICA': 'SOLBIO',
            'MECANICA': 'SOLMEC',
            'INFRAESTRUCTURA': 'SOLINFRA'
        };
        
        this.connectionStatus = 'connecting';
        
        // Almacenar valores v√°lidos detectados
        this.validAccessRequestValues = {
            estado: null,
            servicioHospitalario: [],
            cargo: [],
            availableFields: []
        };
        
        this.validUserValues = {
            estado: null,
            servicioHospitalario: [],
            cargo: []
        };
        
        // Inicializar valores v√°lidos de solicitud
        this.validSolicitudValues = {
            servicioIngenieria: ['INGENIERIA_BIOMEDICA', 'MECANICA', 'INFRAESTRUCTURA'],
            tipoServicio: ['MANTENIMIENTO_PREVENTIVO', 'MANTENIMIENTO_CORRECTIVO', 'REPARACION', 'INSTALACION', 'DESINSTALACION', 'CALIBRACION', 'INSPECCION', 'ACTUALIZACION', 'EMERGENCIA', 'ERROR_USUARIO'],
            prioridad: ['CRITICA', 'ALTA', 'MEDIA', 'BAJA'],
            estado: ['PENDIENTE', 'ASIGNADA', 'EN_PROCESO', 'COMPLETADA', 'CANCELADA'],
            availableFields: []
        };
        
        console.log('üì° URL base:', this.baseUrl);
        console.log('üõ°Ô∏è Usando proxy:', this.useProxy);
        console.log('‚úÖ Tablas configuradas:', Object.keys(this.tables));
        console.log('üó∫Ô∏è Mapeo de valores configurado');
        console.log('üìã Valores iniciales de solicitud:', this.validSolicitudValues);
        console.log('‚ú® NUEVO: Cambio de tipo de servicio al completar');
        
        this.initializeConnectionAsync();
    }

    // üîß FUNCI√ìN CR√çTICA: Limpiar valores de comillas extras y espacios
    cleanFieldValue(value) {
        if (typeof value !== 'string') return value;
        
        let cleanValue = value.trim();
        cleanValue = cleanValue.replace(/"+/g, '"');
        
        if (cleanValue.startsWith('"') && cleanValue.endsWith('"')) {
            cleanValue = cleanValue.slice(1, -1);
        }
        
        cleanValue = cleanValue.replace(/\\"/g, '');
        
        if (cleanValue.startsWith('"') && cleanValue.endsWith('"')) {
            cleanValue = cleanValue.slice(1, -1);
        }
        
        cleanValue = cleanValue.trim();
        
        console.log(`üßπ Limpieza de valor: "${value}" ‚Üí "${cleanValue}"`);
        
        return cleanValue;
    }

    async initializeConnectionAsync() {
        setTimeout(async () => {
            try {
                const isConnected = await this.testConnection();
                
                if (isConnected) {
                    this.connectionStatus = 'connected';
                    this.notifyConnectionStatus(true);
                    console.log('‚úÖ Conectado exitosamente a Airtable');
                    
                    await this.detectValidAccessRequestValues();
                    await this.detectValidUserValues();
                    
                    try {
                        await this.detectValidSolicitudValues();
                    } catch (error) {
                        console.warn('‚ö†Ô∏è No se pudieron detectar valores de solicitudes, usando valores por defecto conocidos');
                    }
                } else {
                    this.connectionStatus = 'disconnected';
                    this.notifyConnectionStatus(false);
                    console.warn('‚ö†Ô∏è Modo localStorage activo');
                }
            } catch (error) {
                console.error('‚ùå Error en inicializaci√≥n:', error);
                this.connectionStatus = 'disconnected';
                this.notifyConnectionStatus(false);
            }
        }, 2000);
    }

    // üîç FUNCI√ìN: Detectar valores v√°lidos para solicitudes de acceso
    async detectValidAccessRequestValues() {
        console.log('üîç Detectando valores y campos v√°lidos para SolicitudesAcceso...');
        
        try {
            const result = await this.makeRequest(`${this.tables.solicitudesAcceso}?maxRecords=20`);
            
            if (result.records && result.records.length > 0) {
                const estadoValues = new Set();
                const servicioValues = new Set();
                const cargoValues = new Set();
                const availableFields = new Set();
                
                result.records.forEach(record => {
                    if (record.fields) {
                        Object.keys(record.fields).forEach(field => {
                            availableFields.add(field);
                        });
                        
                        if (record.fields.estado) {
                            estadoValues.add(record.fields.estado);
                        }
                        if (record.fields.servicioHospitalario) {
                            servicioValues.add(record.fields.servicioHospitalario);
                        }
                        if (record.fields.cargo) {
                            cargoValues.add(record.fields.cargo);
                        }
                    }
                });
                
                console.log('üìã Campos disponibles en SolicitudesAcceso:', Array.from(availableFields));
                
                let pendienteValue = null;
                estadoValues.forEach(value => {
                    const cleanValue = this.cleanFieldValue(value);
                    if (cleanValue.toUpperCase() === 'PENDIENTE') {
                        pendienteValue = value;
                        console.log(`‚úÖ Valor PENDIENTE detectado: "${value}"`);
                    }
                });
                
                this.validAccessRequestValues = {
                    estado: pendienteValue,
                    estadoValues: Array.from(estadoValues),
                    servicioHospitalario: Array.from(servicioValues),
                    cargo: Array.from(cargoValues),
                    availableFields: Array.from(availableFields)
                };
                
                console.log('üìã Valores v√°lidos detectados:', {
                    estado: this.validAccessRequestValues.estado,
                    todosEstados: this.validAccessRequestValues.estadoValues,
                    camposDisponibles: this.validAccessRequestValues.availableFields,
                    servicios: this.validAccessRequestValues.servicioHospitalario.length,
                    cargos: this.validAccessRequestValues.cargo.length
                });
                
                if (!pendienteValue) {
                    console.warn('‚ö†Ô∏è No se encontr√≥ valor PENDIENTE, usando valor por defecto');
                    this.validAccessRequestValues.estado = 'Pendiente';
                }
                
            } else {
                console.warn('‚ö†Ô∏è No hay registros en SolicitudesAcceso para detectar valores');
                this.validAccessRequestValues.estado = 'Pendiente';
            }
            
        } catch (error) {
            console.error('‚ùå Error detectando valores v√°lidos:', error);
            this.validAccessRequestValues.estado = 'Pendiente';
        }
    }

    // üîç Detectar valores v√°lidos para tabla de usuarios
    async detectValidUserValues() {
        console.log('üîç Detectando valores v√°lidos para tabla Usuarios...');
        
        try {
            const result = await this.makeRequest(`${this.tables.usuarios}?maxRecords=10`);
            
            if (result.records && result.records.length > 0) {
                const estadoValues = new Set();
                const servicioValues = new Set();
                const cargoValues = new Set();
                
                result.records.forEach(record => {
                    if (record.fields) {
                        if (record.fields.estado) {
                            estadoValues.add(record.fields.estado);
                        }
                        if (record.fields.servicioHospitalario) {
                            servicioValues.add(record.fields.servicioHospitalario);
                        }
                        if (record.fields.cargo) {
                            cargoValues.add(record.fields.cargo);
                        }
                    }
                });
                
                let activoValue = null;
                estadoValues.forEach(value => {
                    const cleanValue = this.cleanFieldValue(value);
                    if (cleanValue.toUpperCase() === 'ACTIVO') {
                        activoValue = value;
                        console.log(`‚úÖ Valor ACTIVO detectado para usuarios: "${value}"`);
                    }
                });
                
                if (!activoValue && estadoValues.size > 0) {
                    activoValue = Array.from(estadoValues)[0];
                    console.warn(`‚ö†Ô∏è No se encontr√≥ valor ACTIVO, usando: "${activoValue}"`);
                } else if (!activoValue) {
                    activoValue = 'Activo';
                }
                
                this.validUserValues = {
                    estado: activoValue,
                    estadoValues: Array.from(estadoValues),
                    servicioHospitalario: Array.from(servicioValues),
                    cargo: Array.from(cargoValues)
                };
                
                console.log('üìã Valores v√°lidos de usuarios detectados:', {
                    estado: this.validUserValues.estado,
                    todosEstados: this.validUserValues.estadoValues,
                    servicios: this.validUserValues.servicioHospitalario.length,
                    cargos: this.validUserValues.cargo.length
                });
                
            } else {
                console.warn('‚ö†Ô∏è No hay usuarios para detectar valores, usando valores por defecto');
                this.validUserValues.estado = 'Activo';
            }
            
        } catch (error) {
            console.error('‚ùå Error detectando valores v√°lidos de usuarios:', error);
            this.validUserValues.estado = 'Activo';
        }
    }

    // üîç MEJORADO: Detectar valores v√°lidos para tabla de Solicitudes
    async detectValidSolicitudValues() {
        console.log('üîç Detectando valores v√°lidos para tabla Solicitudes...');
        
        try {
            const result = await this.makeRequest(`${this.tables.solicitudes}?maxRecords=50`);
            
            if (result.records && result.records.length > 0) {
                const servicioValues = new Set();
                const tipoServicioValues = new Set();
                const prioridadValues = new Set();
                const estadoValues = new Set();
                const availableFields = new Set();
                
                result.records.forEach(record => {
                    if (record.fields) {
                        Object.keys(record.fields).forEach(field => {
                            availableFields.add(field);
                        });
                        
                        if (record.fields.servicioIngenieria) {
                            const mappedServicio = this.mapFieldValue('servicioIngenieria', record.fields.servicioIngenieria);
                            servicioValues.add(mappedServicio);
                            console.log(`üìã √Årea detectada: "${record.fields.servicioIngenieria}" ‚Üí "${mappedServicio}"`);
                        }
                        if (record.fields.tipoServicio) {
                            const mappedTipo = this.mapFieldValue('tipoServicio', record.fields.tipoServicio);
                            tipoServicioValues.add(mappedTipo);
                        }
                        if (record.fields.prioridad) {
                            const mappedPrioridad = this.mapFieldValue('prioridad', record.fields.prioridad);
                            prioridadValues.add(mappedPrioridad);
                        }
                        if (record.fields.estado) {
                            const mappedEstado = this.mapFieldValue('estado', record.fields.estado);
                            estadoValues.add(mappedEstado);
                        }
                    }
                });
                
                if (servicioValues.size > 0) {
                    this.validSolicitudValues.servicioIngenieria = Array.from(servicioValues);
                }
                if (tipoServicioValues.size > 0) {
                    const tiposDetectados = Array.from(tipoServicioValues);
                    // Asegurar que todos los tipos est√©n incluidos
                    const tiposCompletos = new Set([...tiposDetectados, 'ERROR_USUARIO', 'DESINSTALACION', 'CALIBRACION', 'ACTUALIZACION', 'EMERGENCIA', 'INSPECCION']);
                    this.validSolicitudValues.tipoServicio = Array.from(tiposCompletos);
                }
                if (prioridadValues.size > 0) {
                    this.validSolicitudValues.prioridad = Array.from(prioridadValues);
                }
                if (estadoValues.size > 0) {
                    this.validSolicitudValues.estado = Array.from(estadoValues);
                }
                
                this.validSolicitudValues.availableFields = Array.from(availableFields);
                
                console.log('üìã Valores v√°lidos de solicitudes detectados:', {
                    servicios: this.validSolicitudValues.servicioIngenieria,
                    tipos: this.validSolicitudValues.tipoServicio,
                    prioridades: this.validSolicitudValues.prioridad,
                    estados: this.validSolicitudValues.estado,
                    campos: this.validSolicitudValues.availableFields
                });
                
            } else {
                console.warn('‚ö†Ô∏è No hay registros en Solicitudes para detectar valores');
                console.log('üìã Usando valores conocidos por defecto:', this.validSolicitudValues);
            }
            
        } catch (error) {
            console.error('‚ùå Error detectando valores v√°lidos de solicitudes:', error);
            console.log('üìã Manteniendo valores por defecto conocidos:', this.validSolicitudValues);
        }
    }

    notifyConnectionStatus(connected) {
        try {
            const event = new CustomEvent('airtableConnectionUpdate', {
                detail: { 
                    connected, 
                    timestamp: new Date(),
                    method: this.useProxy ? 'proxy' : 'direct',
                    hostname: this.hostname
                }
            });
            window.dispatchEvent(event);
        } catch (error) {
            console.warn('‚ö†Ô∏è No se pudo notificar cambio de estado:', error);
        }
    }

    async makeRequest(endpoint, method = 'GET', data = null) {
        console.log('üì° Request:', method, endpoint);
        
        try {
            let url, options;
            
            if (this.useProxy) {
                url = `${this.baseUrl}/${endpoint}`;
                options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors',
                    credentials: 'same-origin'
                };
            } else {
                url = `${this.baseUrl}/${endpoint}`;
                options = {
                    method: method,
                    headers: {
                        'Authorization': `Bearer ${this.directApiKey}`,
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                };
            }
            
            if (data && (method === 'POST' || method === 'PATCH')) {
                options.body = JSON.stringify(data);
                console.log('üìä Datos enviados:', JSON.stringify(data, null, 2));
            }
            
            const response = await fetch(url, options);
            
            console.log('üì® Status:', response.status);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('‚ùå Error response:', errorText);
                
                if (response.status === 422) {
                    console.error('üö® ERROR 422 - Valores de campo inv√°lidos');
                    console.error('üîç Datos enviados:', data);
                    
                    try {
                        const errorData = JSON.parse(errorText);
                        if (errorData.error && errorData.error.type === 'INVALID_MULTIPLE_CHOICE_OPTIONS') {
                            const message = errorData.error.message || '';
                            const fieldMatch = message.match(/field (\w+)/);
                            const valueMatch = message.match(/option "(.+?)"/);
                            
                            if (fieldMatch && valueMatch) {
                                const fieldName = fieldMatch[1];
                                const invalidValue = valueMatch[1];
                                console.error(`üéØ Campo: ${fieldName}, Valor inv√°lido: "${invalidValue}"`);
                                
                                console.log('üí° SOLUCI√ìN: Verificar valores v√°lidos en Airtable para el campo', fieldName);
                                console.log('üí° Valores detectados:', this.validSolicitudValues);
                            }
                        }
                    } catch (parseError) {
                        console.error('Error parseando respuesta 422:', parseError);
                    }
                    
                    throw new Error(`HTTP 422: Valores inv√°lidos. Verificar configuraci√≥n de campos en Airtable.`);
                }
                
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
            const result = await response.json();
            console.log('‚úÖ Request exitoso');
            
            return result;
            
        } catch (error) {
            console.error('‚ùå Request fall√≥:', error);
            throw error;
        }
    }

    async testConnection() {
        console.log('üß™ Test de conexi√≥n...');
        
        try {
            const response = await this.makeRequest(`${this.tables.solicitudes}?maxRecords=1`);
            return true;
        } catch (error) {
            console.error('‚ùå Test fall√≥:', error.message);
            return false;
        }
    }

    // üîê M√âTODO: Crear solicitud de acceso
    async createSolicitudAcceso(solicitudData) {
        console.log('üìù Creando solicitud de acceso con detecci√≥n autom√°tica de valores...');
        console.log('üîç Datos recibidos:', solicitudData);
        
        try {
            const cleanData = {};
            Object.keys(solicitudData).forEach(key => {
                const value = solicitudData[key];
                if (typeof value === 'string') {
                    cleanData[key] = this.cleanFieldValue(value);
                } else {
                    cleanData[key] = value;
                }
            });
            
            const baseData = {
                nombreCompleto: cleanData.nombreCompleto || '',
                email: cleanData.email || '',
                telefono: cleanData.telefono || '',
                servicioHospitalario: cleanData.servicioHospitalario || '',
                cargo: cleanData.cargo || '',
                justificacion: cleanData.justificacion || '',
                fechaSolicitud: cleanData.fechaSolicitud || new Date().toISOString(),
                esUrgente: cleanData.esUrgente || false
            };
            
            if (this.validAccessRequestValues.estado) {
                console.log(`‚úÖ Usando valor de estado detectado: "${this.validAccessRequestValues.estado}"`);
                baseData.estado = this.validAccessRequestValues.estado;
            } else {
                console.log('üìã Usando valor de estado por defecto: "Pendiente"');
                baseData.estado = 'Pendiente';
            }
            
            const data = {
                fields: baseData
            };
            
            console.log('üìù Datos finales a enviar:', JSON.stringify(data, null, 2));
            
            try {
                const result = await this.makeRequest(this.tables.solicitudesAcceso, 'POST', data);
                console.log('‚úÖ Solicitud de acceso creada exitosamente:', result.id);
                return result;
                
            } catch (error) {
                if (error.message.includes('422') && error.message.includes('estado')) {
                    console.warn('‚ö†Ô∏è Error con campo estado, reintentando sin estado...');
                    
                    delete baseData.estado;
                    const dataWithoutEstado = { fields: baseData };
                    
                    const result = await this.makeRequest(this.tables.solicitudesAcceso, 'POST', dataWithoutEstado);
                    console.log('‚úÖ Solicitud creada sin campo estado:', result.id);
                    return result;
                }
                
                throw error;
            }
            
        } catch (error) {
            console.error('‚ùå Error creando solicitud de acceso:', error);
            
            if (error.message.includes('422')) {
                console.log('üîÑ √öltimo intento con campos m√≠nimos...');
                return await this.createSolicitudAccesoMinimal(solicitudData);
            }
            
            throw error;
        }
    }

    // M√©todo fallback para crear solicitud con campos m√≠nimos
    async createSolicitudAccesoMinimal(solicitudData) {
        console.log('üîÑ Creando solicitud de acceso con campos absolutamente m√≠nimos...');
        
        try {
            const data = {
                fields: {
                    nombreCompleto: this.cleanFieldValue(solicitudData.nombreCompleto || 'Sin nombre'),
                    email: this.cleanFieldValue(solicitudData.email || 'no-email@temp.com'),
                    fechaSolicitud: new Date().toISOString()
                }
            };
            
            console.log('üìù Datos m√≠nimos:', data);
            const result = await this.makeRequest(this.tables.solicitudesAcceso, 'POST', data);
            
            console.log('‚úÖ Solicitud creada con campos m√≠nimos:', result.id);
            
            const fieldsToAdd = [
                { telefono: solicitudData.telefono },
                { servicioHospitalario: solicitudData.servicioHospitalario },
                { cargo: solicitudData.cargo },
                { justificacion: solicitudData.justificacion }
            ];
            
            for (const fieldObj of fieldsToAdd) {
                const [fieldName, fieldValue] = Object.entries(fieldObj)[0];
                if (fieldValue) {
                    try {
                        await this.makeRequest(`${this.tables.solicitudesAcceso}/${result.id}`, 'PATCH', {
                            fields: { [fieldName]: this.cleanFieldValue(fieldValue) }
                        });
                        console.log(`‚úÖ Campo ${fieldName} agregado`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo agregar campo ${fieldName}:`, error.message);
                    }
                }
            }
            
            return result;
            
        } catch (error) {
            console.error('‚ùå Error incluso con campos m√≠nimos:', error);
            throw new Error('No se pudo crear la solicitud. Por favor contacte al administrador.');
        }
    }
	async getUsuarios() {
    console.log('üë§ Obteniendo TODOS los usuarios con paginaci√≥n...');
    
    try {
        let allRecords = [];
        let offset = null;
        let pageCount = 0;
        
        do {
            let endpoint = this.tables.usuarios;
            if (offset) {
                endpoint += `?offset=${offset}`;
            }
            
            const result = await this.makeRequest(endpoint);
            
            if (result.records && result.records.length > 0) {
                const pageRecords = result.records.map(record => ({
                    id: record.id,
                    ...record.fields
                }));
                allRecords = allRecords.concat(pageRecords);
            }
            
            offset = result.offset || null;
            pageCount++;
            
            if (pageCount > 20) break;
            
        } while (offset);
        
        console.log(`‚úÖ Total de usuarios obtenidos: ${allRecords.length}`);
        return allRecords;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo usuarios:', error);
        return [];
    }
}
async getSolicitudesAcceso() {
    console.log('üîê Obteniendo TODAS las solicitudes de acceso con paginaci√≥n...');
    
    try {
        let allRecords = [];
        let offset = null;
        let pageCount = 0;
        
        do {
            let endpoint = this.tables.solicitudesAcceso;
            if (offset) {
                endpoint += `?offset=${offset}`;
            }
            
            const result = await this.makeRequest(endpoint);
            
            if (result.records && result.records.length > 0) {
                const pageRecords = result.records.map(record => ({
                    id: record.id,
                    ...record.fields
                }));
                allRecords = allRecords.concat(pageRecords);
            }
            
            offset = result.offset || null;
            pageCount++;
            
            if (pageCount > 20) break;
            
        } while (offset);
        
        console.log(`‚úÖ Total de solicitudes de acceso obtenidas: ${allRecords.length}`);
        return allRecords;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo solicitudes de acceso:', error);
        return [];
    }
}
    // üîê M√âTODO: Aprobar solicitud y crear usuario
    async approveAccessRequestAndCreateUser(requestId) {
        console.log('‚úÖ Iniciando aprobaci√≥n de solicitud:', requestId);
        
        try {
            const solicitudesAcceso = await this.getSolicitudesAcceso();
            const solicitud = solicitudesAcceso.find(s => s.id === requestId);
            
            if (!solicitud) {
                throw new Error('Solicitud de acceso no encontrada');
            }

            if (solicitud.estado === 'APROBADA' || solicitud.estado === 'Aprobada') {
                throw new Error('La solicitud ya fue aprobada anteriormente');
            }

            const codigoAcceso = Math.floor(1000 + Math.random() * 9000).toString();
            console.log(`üîê C√≥digo generado: ${codigoAcceso}`);

            if (!this.validUserValues.estado) {
                await this.detectValidUserValues();
            }

            const userData = {
                nombreCompleto: this.cleanFieldValue(solicitud.nombreCompleto || 'Sin nombre'),
                email: this.cleanFieldValue(solicitud.email || 'no-email@temp.com'),
                servicioHospitalario: this.cleanFieldValue(solicitud.servicioHospitalario || ''),
                cargo: this.cleanFieldValue(solicitud.cargo || ''),
                codigoAcceso: codigoAcceso,
                fechaCreacion: new Date().toISOString(),
                solicitudOrigenId: requestId
            };

            if (this.validUserValues.estado) {
                userData.estado = this.validUserValues.estado;
            } else {
                userData.estado = 'Activo';
                console.warn('‚ö†Ô∏è Usando valor de estado por defecto: "Activo"');
            }

            console.log('üìù Datos del usuario a crear:', userData);

            let newUser;
            try {
                newUser = await this.makeRequest(this.tables.usuarios, 'POST', {
                    fields: userData
                });
                console.log('‚úÖ Usuario creado exitosamente:', newUser.id);
                
            } catch (error) {
                if (error.message.includes('422')) {
                    console.warn('‚ö†Ô∏è Error 422 al crear usuario, reintentando con campos m√≠nimos...');
                    
                    const minimalUserData = {
                        nombreCompleto: userData.nombreCompleto,
                        email: userData.email,
                        codigoAcceso: userData.codigoAcceso,
                        fechaCreacion: userData.fechaCreacion
                    };
                    
                    newUser = await this.makeRequest(this.tables.usuarios, 'POST', {
                        fields: minimalUserData
                    });
                    
                    console.log('‚úÖ Usuario creado con campos m√≠nimos:', newUser.id);
                } else {
                    throw error;
                }
            }

            try {
                let aprobadasValue = 'Aprobada';
                if (this.validAccessRequestValues.estadoValues) {
                    const aprobadaDetectada = this.validAccessRequestValues.estadoValues.find(v => 
                        v.toUpperCase().includes('APROBADA') || v.toUpperCase().includes('APROBADO')
                    );
                    if (aprobadaDetectada) {
                        aprobadasValue = aprobadaDetectada;
                        console.log(`‚úÖ Usando valor de estado detectado: "${aprobadasValue}"`);
                    }
                }

                const updateFields = {
                    estado: aprobadasValue
                };
                
                if (this.validAccessRequestValues.availableFields.includes('usuarioCreado')) {
                    updateFields.usuarioCreado = newUser.id;
                }

                console.log('üìù Actualizando solicitud con campos:', updateFields);

                await this.makeRequest(`${this.tables.solicitudesAcceso}/${requestId}`, 'PATCH', {
                    fields: updateFields
                });
                
                console.log('‚úÖ Solicitud de acceso actualizada');
                
            } catch (updateError) {
                console.error('‚ùå Error actualizando solicitud de acceso:', updateError);
                console.warn('‚ö†Ô∏è El usuario fue creado pero no se pudo actualizar completamente la solicitud');
            }

            return {
                success: true,
                user: {
                    id: newUser.id,
                    ...newUser.fields
                },
                accessCode: codigoAcceso,
                requestId: requestId
            };

        } catch (error) {
            console.error('‚ùå Error en aprobaci√≥n:', error);
            throw error;
        }
    }

async getSolicitudes() {
    console.log('üìã Obteniendo TODAS las solicitudes con paginaci√≥n mejorada...');
    
    try {
        const allRecordsMap = new Map();
        let offset = null;
        let pageCount = 0;
        let totalRecordsProcessed = 0;
        
        // Configuraci√≥n mejorada
        const MAX_PAGES = 100; // Aumentar l√≠mite de p√°ginas
        const PAGE_SIZE = 100; // Mantener tama√±o de p√°gina en 100
        
        while (pageCount < MAX_PAGES) {
            // Construir endpoint sin sort para evitar problemas
            let endpoint = `${this.tables.solicitudes}?pageSize=${PAGE_SIZE}`;
            
            // Agregar offset si existe
            if (offset) {
                endpoint += `&offset=${encodeURIComponent(offset)}`;
            }
            
            pageCount++;
            console.log(`üìÑ Obteniendo p√°gina ${pageCount}...`);
            
            try {
                const result = await this.makeRequest(endpoint);
                
                // Verificar si hay registros
                if (!result.records || result.records.length === 0) {
                    console.log(`‚úÖ P√°gina ${pageCount} vac√≠a - fin de datos`);
                    break;
                }
                
                // Procesar registros
                let newRecords = 0;
                result.records.forEach(record => {
                    const recordId = record.id;
                    
                    if (!allRecordsMap.has(recordId)) {
                        allRecordsMap.set(recordId, {
                            id: recordId,
                            ...record.fields
                        });
                        newRecords++;
                        totalRecordsProcessed++;
                    }
                });
                
                console.log(`üìä P√°gina ${pageCount}: ${result.records.length} registros, ${newRecords} nuevos (Total acumulado: ${allRecordsMap.size})`);
                
                // Obtener siguiente offset
                offset = result.offset;
                
                // Si no hay offset, hemos terminado
                if (!offset) {
                    console.log('‚úÖ No hay m√°s p√°ginas - paginaci√≥n completa');
                    break;
                }
                
                // Peque√±a pausa entre requests para no sobrecargar
                await new Promise(resolve => setTimeout(resolve, 100));
                
            } catch (pageError) {
                console.error(`‚ùå Error en p√°gina ${pageCount}:`, pageError.message);
                
                // Si es un error de red, reintentar
                if (pageError.message && pageError.message.includes('fetch')) {
                    console.log('üîÑ Reintentando p√°gina...');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    pageCount--; // Decrementar para reintentar la misma p√°gina
                    continue;
                }
                
                // Para otros errores, continuar con la siguiente p√°gina
                break;
            }
        }
        
        const finalRecords = Array.from(allRecordsMap.values());
        
        // An√°lisis detallado de los resultados
        console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log('‚ïë   RESUMEN DE SOLICITUDES OBTENIDAS      ‚ïë');
        console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
        console.log(`‚ïë ‚úÖ TOTAL: ${finalRecords.length} solicitudes`);
        console.log(`‚ïë üìÑ P√°ginas procesadas: ${pageCount}`);
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
        
        // An√°lisis por √°rea
        this.analizarSolicitudesPorArea(finalRecords);
        
        return finalRecords;
        
    } catch (error) {
        console.error('‚ùå Error cr√≠tico obteniendo solicitudes:', error);
        throw error;
    }
}

// Agregar este m√©todo auxiliar despu√©s del m√©todo getSolicitudes
analizarSolicitudesPorArea(records) {
    const porArea = {};
    const porEstado = {};
    
    records.forEach(r => {
        // Por √°rea
        const area = r.servicioIngenieria || 'SIN_AREA';
        porArea[area] = (porArea[area] || 0) + 1;
        
        // Por estado
        const estado = r.estado || 'SIN_ESTADO';
        porEstado[estado] = (porEstado[estado] || 0) + 1;
    });
    
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë   AN√ÅLISIS DETALLADO POR √ÅREA           ‚ïë');
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    
    // An√°lisis espec√≠fico de √°reas principales
    let totalBiomedica = 0;
    let totalMecanica = 0;
    let totalInfraestructura = 0;
    let sinArea = 0;
    
    Object.entries(porArea).forEach(([area, count]) => {
        const areaLower = area.toLowerCase();
        
        if (area === 'INGENIERIA_BIOMEDICA' || 
            area === 'Ingenier√≠a Biom√©dica' ||
            areaLower.includes('biomed') || 
            areaLower.includes('biom√©d')) {
            totalBiomedica += count;
            console.log(`‚ïë üè• ${area}: ${count}`);
        } else if (area === 'MECANICA' || 
                   area === 'Mec√°nica' ||
                   areaLower.includes('mec√°n') ||
                   areaLower.includes('mecan')) {
            totalMecanica += count;
            console.log(`‚ïë ‚öôÔ∏è ${area}: ${count}`);
        } else if (area === 'INFRAESTRUCTURA' || 
                   area === 'Infraestructura' ||
                   areaLower.includes('infra')) {
            totalInfraestructura += count;
            console.log(`‚ïë üèóÔ∏è ${area}: ${count}`);
        } else if (area === 'SIN_AREA') {
            sinArea = count;
            console.log(`‚ïë ‚ùì Sin √°rea definida: ${count}`);
        } else {
            console.log(`‚ïë üìã ${area}: ${count}`);
        }
    });
    
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log('‚ïë   TOTALES POR CATEGOR√çA                 ‚ïë');
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë üè• BIOM√âDICA TOTAL: ${totalBiomedica}`);
    console.log(`‚ïë ‚öôÔ∏è MEC√ÅNICA TOTAL: ${totalMecanica}`);
    console.log(`‚ïë üèóÔ∏è INFRAESTRUCTURA TOTAL: ${totalInfraestructura}`);
    if (sinArea > 0) {
        console.log(`‚ïë ‚ùì SIN √ÅREA: ${sinArea}`);
    }
    console.log(`‚ïë üìä GRAN TOTAL: ${records.length}`);
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    
    // An√°lisis por estado (top 5)
    console.log('\nüìä TOP 5 ESTADOS:');
    Object.entries(porEstado)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .forEach(([estado, count]) => {
            console.log(`   ${estado}: ${count}`);
        });
}
// Funci√≥n de diagn√≥stico mejorada
window.diagnosticarSolicitudes = async function() {
    console.log('üîç DIAGN√ìSTICO COMPLETO DE SOLICITUDES');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    try {
        // Forzar recarga completa
        console.log('üì° Obteniendo datos frescos de Airtable...');
        
        const solicitudes = await window.airtableAPI.getSolicitudes();
        
        console.log(`\nüìä RESULTADO FINAL:`);
        console.log(`   Total obtenido: ${solicitudes.length} solicitudes`);
        console.log(`   Esperado: 233 solicitudes`);
        console.log(`   Diferencia: ${233 - solicitudes.length}`);
        
        if (solicitudes.length < 233) {
            console.warn('‚ö†Ô∏è FALTAN SOLICITUDES - Verificar paginaci√≥n');
            console.log('üí° Ejecuta window.forzarRecargaCompleta() para intentar otra vez');
        } else if (solicitudes.length === 233) {
            console.log('‚úÖ TODAS LAS SOLICITUDES CARGADAS CORRECTAMENTE');
        } else if (solicitudes.length > 233) {
            console.log('üìà Se encontraron M√ÅS solicitudes de las esperadas');
        }
        
        return {
            total: solicitudes.length,
            esperado: 233,
            diferencia: 233 - solicitudes.length,
            solicitudes: solicitudes
        };
        
    } catch (error) {
        console.error('‚ùå Error en diagn√≥stico:', error);
        return null;
    }
};

// Funci√≥n para forzar recarga completa
window.forzarRecargaCompleta = async function() {
    console.log('üîÑ FORZANDO RECARGA COMPLETA DE DATOS...');
    
    try {
        // Limpiar datos en memoria
        if (window.airtableAPI) {
            console.log('üßπ Limpiando cach√©...');
            
            // Obtener nuevos datos
            const solicitudes = await window.airtableAPI.getSolicitudes();
            
            console.log(`‚úÖ Recarga completa exitosa`);
            console.log(`üìä Total de solicitudes: ${solicitudes.length}`);
            
            // Si est√°s en el portal de gesti√≥n, actualizar la interfaz
            if (typeof loadAllDataFromCloud === 'function') {
                console.log('üîÑ Actualizando interfaz...');
                await loadAllDataFromCloud();
            }
            
            return solicitudes.length;
        }
    } catch (error) {
        console.error('‚ùå Error en recarga:', error);
        return null;
    }
};
// M√©todo alternativo usando filtros
async getSolicitudesAlternativo() {
    console.log('üîÑ Usando m√©todo alternativo con m√∫ltiples consultas...');
    
    try {
        const allRecords = new Map();
        
        // Intentar obtener por √°reas espec√≠ficas
        const areas = [
            'INGENIERIA_BIOMEDICA',
            'BIOMEDICA', 
            'MECANICA',
            'INFRAESTRUCTURA'
        ];
        
        for (const area of areas) {
            console.log(`üìã Obteniendo solicitudes de ${area}...`);
            
            try {
                // Intentar con filtro por √°rea
                const filterFormula = encodeURIComponent(`{servicioIngenieria}="${area}"`);
                const endpoint = `${this.tables.solicitudes}?filterByFormula=${filterFormula}&pageSize=100`;
                
                let offset = null;
                let areaPageCount = 0;
                
                do {
                    const finalEndpoint = offset ? `${endpoint}&offset=${encodeURIComponent(offset)}` : endpoint;
                    const result = await this.makeRequest(finalEndpoint);
                    
                    if (result.records && result.records.length > 0) {
                        result.records.forEach(record => {
                            if (!allRecords.has(record.id)) {
                                allRecords.set(record.id, {
                                    id: record.id,
                                    ...record.fields
                                });
                            }
                        });
                        
                        console.log(`   P√°gina ${++areaPageCount}: ${result.records.length} registros`);
                    }
                    
                    offset = result.offset;
                    
                } while (offset && areaPageCount < 10);
                
                console.log(`   ‚úÖ ${area}: ${allRecords.size} registros totales acumulados`);
                
            } catch (areaError) {
                console.warn(`   ‚ö†Ô∏è Error obteniendo ${area}:`, areaError.message);
            }
        }
        
        // Tambi√©n intentar obtener registros sin √°rea definida
        try {
            console.log('üìã Obteniendo solicitudes sin √°rea definida...');
            const filterFormula = encodeURIComponent('OR({servicioIngenieria}="",NOT({servicioIngenieria}))');
            const endpoint = `${this.tables.solicitudes}?filterByFormula=${filterFormula}&pageSize=100`;
            
            const result = await this.makeRequest(endpoint);
            
            if (result.records) {
                result.records.forEach(record => {
                    if (!allRecords.has(record.id)) {
                        allRecords.set(record.id, {
                            id: record.id,
                            ...record.fields
                        });
                    }
                });
                console.log(`   ‚úÖ Sin √°rea: ${result.records.length} registros`);
            }
        } catch (e) {
            console.warn('   ‚ö†Ô∏è No se pudieron obtener registros sin √°rea');
        }
        
        const finalRecords = Array.from(allRecords.values());
        
        console.log(`‚úÖ TOTAL M√âTODO ALTERNATIVO: ${finalRecords.length} registros √∫nicos`);
        
        // Si a√∫n tenemos pocos registros, intentar sin filtros por lotes
        if (finalRecords.length < 200) {
            console.log('üîÑ Intentando obtenci√≥n por lotes temporales...');
            return await this.getSolicitudesPorLotes();
        }
        
        this.analizarSolicitudes(finalRecords);
        return finalRecords;
        
    } catch (error) {
        console.error('‚ùå Error en m√©todo alternativo:', error);
        return [];
    }
}

// M√©todo por lotes temporales
async getSolicitudesPorLotes() {
    console.log('üîÑ Obteniendo solicitudes por lotes temporales...');
    
    try {
        const allRecords = new Map();
        const ahora = new Date();
        
        // Intentar por meses hacia atr√°s
        for (let monthsBack = 0; monthsBack < 12; monthsBack++) {
            const fechaInicio = new Date(ahora.getFullYear(), ahora.getMonth() - monthsBack - 1, 1);
            const fechaFin = new Date(ahora.getFullYear(), ahora.getMonth() - monthsBack, 0);
            
            const filterFormula = encodeURIComponent(
                `AND(IS_AFTER({fechaCreacion}, "${fechaInicio.toISOString()}"), ` +
                `IS_BEFORE({fechaCreacion}, "${fechaFin.toISOString()}"))`
            );
            
            try {
                const endpoint = `${this.tables.solicitudes}?filterByFormula=${filterFormula}&pageSize=100`;
                const result = await this.makeRequest(endpoint);
                
                if (result.records) {
                    result.records.forEach(record => {
                        allRecords.set(record.id, {
                            id: record.id,
                            ...record.fields
                        });
                    });
                    
                    console.log(`   üìÖ ${fechaInicio.toLocaleDateString()} - ${fechaFin.toLocaleDateString()}: ${result.records.length} registros`);
                }
            } catch (e) {
                console.warn(`   ‚ö†Ô∏è Error en lote temporal:`, e.message);
            }
            
            // Si ya tenemos suficientes registros, parar
            if (allRecords.size >= 233) {
                console.log('‚úÖ Se alcanz√≥ el n√∫mero esperado de registros');
                break;
            }
        }
        
        const finalRecords = Array.from(allRecords.values());
        console.log(`‚úÖ TOTAL POR LOTES: ${finalRecords.length} registros`);
        
        this.analizarSolicitudes(finalRecords);
        return finalRecords;
        
    } catch (error) {
        console.error('‚ùå Error en obtenci√≥n por lotes:', error);
        return [];
    }
}

// Funci√≥n auxiliar para analizar solicitudes
analizarSolicitudes(records) {
    const porArea = {};
    const porEstado = {};
    
    records.forEach(r => {
        // Por √°rea
        const area = r.servicioIngenieria || 'SIN_AREA';
        porArea[area] = (porArea[area] || 0) + 1;
        
        // Por estado
        const estado = r.estado || 'SIN_ESTADO';
        porEstado[estado] = (porEstado[estado] || 0) + 1;
    });
    
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë   AN√ÅLISIS FINAL DE SOLICITUDES        ‚ïë');
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë ‚úÖ TOTAL: ${records.length} solicitudes`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log('‚ïë üìä POR √ÅREA:                           ‚ïë');
    Object.entries(porArea)
        .sort((a, b) => b[1] - a[1])
        .forEach(([area, count]) => {
            console.log(`‚ïë   ${area}: ${count}`);
        });
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log('‚ïë üìä POR ESTADO:                         ‚ïë');
    Object.entries(porEstado)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .forEach(([estado, count]) => {
            console.log(`‚ïë   ${estado}: ${count}`);
        });
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
}
// M√©todo alternativo sin sort (backup)
async getSolicitudesWithoutSort() {
    console.log('üìã Obteniendo solicitudes sin sort (m√©todo alternativo)...');
    
    try {
        let allRecords = [];
        let offset = null;
        let pageCount = 0;
        const pageSize = 100;
        let previousTotal = 0;
        let sameCountAttempts = 0;
        
        do {
            let endpoint = `${this.tables.solicitudes}?pageSize=${pageSize}`;
            
            if (offset) {
                endpoint += `&offset=${offset}`;
            }
            
            console.log(`üîÑ P√°gina ${pageCount + 1} (sin sort)...`);
            
            const result = await this.makeRequest(endpoint);
            
            if (result.records && result.records.length > 0) {
                const pageRecords = result.records.map(record => ({
                    id: record.id,
                    ...record.fields
                }));
                
                // Verificar si hay duplicados antes de agregar
                const currentIds = new Set(allRecords.map(r => r.id));
                const newRecords = pageRecords.filter(r => !currentIds.has(r.id));
                
                allRecords = allRecords.concat(newRecords);
                console.log(`‚úÖ P√°gina ${pageCount + 1}: ${newRecords.length} nuevos registros (Total: ${allRecords.length})`);
                
                // Verificar si estamos obteniendo registros nuevos
                if (allRecords.length === previousTotal) {
                    sameCountAttempts++;
                    if (sameCountAttempts >= 3) {
                        console.log('‚ö†Ô∏è No se est√°n obteniendo nuevos registros, finalizando...');
                        break;
                    }
                } else {
                    sameCountAttempts = 0;
                }
                previousTotal = allRecords.length;
            }
            
            offset = result.offset || null;
            pageCount++;
            
            // L√≠mite de seguridad
            if (pageCount > 50) {
                console.warn('‚ö†Ô∏è L√≠mite de p√°ginas alcanzado');
                break;
            }
            
            // Pausa entre requests
            if (offset) {
                await new Promise(resolve => setTimeout(resolve, 150));
            }
            
        } while (offset);
        
        // Eliminar duplicados finales
        const uniqueRecords = new Map();
        allRecords.forEach(record => {
            uniqueRecords.set(record.id, record);
        });
        
        return Array.from(uniqueRecords.values());
        
    } catch (error) {
        console.error('‚ùå Error en m√©todo alternativo:', error);
        return [];
    }
}
async getTecnicos() {
    console.log('üë• Obteniendo TODOS los t√©cnicos con paginaci√≥n...');
    
    try {
        let allRecords = [];
        let offset = null;
        let pageCount = 0;
        
        do {
            let endpoint = `${this.tables.tecnicos}?pageSize=100`;
            if (offset) {
                endpoint += `&offset=${offset}`;
            }
            
            const result = await this.makeRequest(endpoint);
            
            if (result.records && result.records.length > 0) {
                const pageRecords = result.records.map(record => ({
                    id: record.id,
                    ...record.fields
                }));
                allRecords = allRecords.concat(pageRecords);
            }
            
            offset = result.offset || null;
            pageCount++;
            
            if (pageCount > 50) break;
            
        } while (offset);
        
        console.log(`‚úÖ Total de t√©cnicos obtenidos: ${allRecords.length}`);
        return allRecords;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo t√©cnicos:', error);
        return [];
    }
}

async getUsuarios() {
    console.log('üë§ Obteniendo TODOS los usuarios con paginaci√≥n...');
    
    try {
        let allRecords = [];
        let offset = null;
        let pageCount = 0;
        
        do {
            let endpoint = `${this.tables.usuarios}?pageSize=100`;
            if (offset) {
                endpoint += `&offset=${offset}`;
            }
            
            const result = await this.makeRequest(endpoint);
            
            if (result.records && result.records.length > 0) {
                const pageRecords = result.records.map(record => ({
                    id: record.id,
                    ...record.fields
                }));
                allRecords = allRecords.concat(pageRecords);
            }
            
            offset = result.offset || null;
            pageCount++;
            
            if (pageCount > 50) break;
            
        } while (offset);
        
        console.log(`‚úÖ Total de usuarios obtenidos: ${allRecords.length}`);
        return allRecords;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo usuarios:', error);
        return [];
    }
}

async getSolicitudesAcceso() {
    console.log('üîê Obteniendo TODAS las solicitudes de acceso con paginaci√≥n...');
    
    try {
        let allRecords = [];
        let offset = null;
        let pageCount = 0;
        
        do {
            let endpoint = `${this.tables.solicitudesAcceso}?pageSize=100`;
            if (offset) {
                endpoint += `&offset=${offset}`;
            }
            
            const result = await this.makeRequest(endpoint);
            
            if (result.records && result.records.length > 0) {
                const pageRecords = result.records.map(record => ({
                    id: record.id,
                    ...record.fields
                }));
                allRecords = allRecords.concat(pageRecords);
            }
            
            offset = result.offset || null;
            pageCount++;
            
            if (pageCount > 50) break;
            
        } while (offset);
        
        console.log(`‚úÖ Total de solicitudes de acceso obtenidas: ${allRecords.length}`);
        return allRecords;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo solicitudes de acceso:', error);
        return [];
    }
}

    async validateUserCredentials(email, codigoAcceso) {
        try {
            const usuarios = await this.getUsuarios();
            const user = usuarios.find(u => 
                u.email && u.email.toLowerCase() === email.toLowerCase()
            );
            
            if (!user) {
                return { valid: false, error: 'Usuario no encontrado' };
            }

            const estadoActivo = ['ACTIVO', 'Activo', 'activo'];
            if (!estadoActivo.includes(user.estado)) {
                return { valid: false, error: `Usuario en estado: ${user.estado}` };
            }

            if (String(user.codigoAcceso) !== String(codigoAcceso)) {
                return { valid: false, error: 'C√≥digo incorrecto' };
            }

            return { valid: true, user: user };

        } catch (error) {
            console.error('‚ùå Error validando credenciales:', error);
            return { valid: false, error: 'Error de sistema' };
        }
    }

    mapFieldValue(fieldType, value) {
        if (!value) return value;
        
        const cleanValue = this.cleanFieldValue(value);
        
        console.log(`üó∫Ô∏è Mapeando ${fieldType}: "${cleanValue}"`);
        
        if (this.fieldMappings[fieldType]) {
            const mapping = this.fieldMappings[fieldType];
            
            if (mapping[cleanValue]) {
                const mappedValue = mapping[cleanValue];
                console.log(`‚úÖ Mapeado ${fieldType}: "${cleanValue}" ‚Üí "${mappedValue}"`);
                return mappedValue;
            }
            
            for (const [key, mappedValue] of Object.entries(mapping)) {
                if (mappedValue === cleanValue) {
                    console.log(`‚úÖ Valor ya mapeado correctamente: "${cleanValue}"`);
                    return mappedValue;
                }
            }
        }
        
        console.log(`‚ö†Ô∏è No se encontr√≥ mapeo para ${fieldType}: "${cleanValue}" - usando valor original`);
        return cleanValue;
    }

    prepareSafeData(data, tableName) {
        console.log(`üõ°Ô∏è Preparando datos seguros para tabla: ${tableName}`);
        console.log(`üîç Datos originales:`, data);
        
        const safeFields = SAFE_FIELDS[tableName] || [];
        const safeData = {};
        
        Object.keys(data).forEach(key => {
            if (safeFields.includes(key)) {
                let value = data[key];
                
                if (typeof value === 'string') {
                    value = this.cleanFieldValue(value);
                }
                
                if (this.fieldMappings[key]) {
                    const originalValue = value;
                    value = this.mapFieldValue(key, value);
                    if (originalValue !== value) {
                        console.log(`üó∫Ô∏è MAPEO APLICADO para ${key}: "${originalValue}" ‚Üí "${value}"`);
                    }
                }
                
                safeData[key] = value;
                console.log(`‚úÖ Campo ${key}: ${value}`);
            } else {
                console.warn(`‚ö†Ô∏è Campo '${key}' omitido - no est√° en lista segura para ${tableName}`);
            }
        });
        
        console.log(`‚úÖ Datos seguros preparados:`, safeData);
        return safeData;
    }

    async generateAreaSpecificNumber(area) {
        console.log('üî¢ Generando n√∫mero espec√≠fico para √°rea:', area);
        
        try {
            let normalizedArea = area;
            if (area && (area.toLowerCase().includes('biomed') || area.toLowerCase().includes('biom√©d'))) {
                normalizedArea = 'INGENIERIA_BIOMEDICA';
                console.log(`üîß √Årea normalizada: ${area} ‚Üí ${normalizedArea}`);
            }
            
            const solicitudes = await this.getSolicitudes();
            
            const prefix = this.areaPrefixes[normalizedArea];
            if (!prefix) {
                console.warn('‚ö†Ô∏è √Årea no reconocida, usando formato est√°ndar');
                return `SOL${Date.now()}${Math.random().toString(36).substring(2, 3).toUpperCase()}`;
            }

            const areaRequests = solicitudes.filter(s => 
                s.numero && s.numero.startsWith(prefix)
            );

            let maxNumber = 0;
            areaRequests.forEach(solicitud => {
                const numberPart = solicitud.numero.replace(prefix, '');
                const num = parseInt(numberPart);
                if (!isNaN(num) && num > maxNumber) {
                    maxNumber = num;
                }
            });

            const nextNumber = maxNumber + 1;
            const formattedNumber = nextNumber.toString().padStart(5, '0');
            const newRequestNumber = `${prefix}${formattedNumber}`;

            console.log(`‚úÖ N√∫mero generado para ${normalizedArea}: ${newRequestNumber} (siguiente: ${nextNumber})`);
            return newRequestNumber;

        } catch (error) {
            console.error('‚ùå Error generando n√∫mero espec√≠fico:', error);
            const prefix = this.areaPrefixes[area] || 'SOL';
            const randomPart = Date.now().toString().slice(-5);
            return `${prefix}${randomPart}`;
        }
    }

    // üìã M√âTODO: Crear solicitud
    async createSolicitud(solicitudData) {
        console.log('üìù Creando solicitud con mapeo y valores conocidos...');
        console.log('üîç Datos recibidos:', solicitudData);
        console.log('üè• √ÅREA RECIBIDA:', solicitudData.servicioIngenieria);
        console.log('üìã Valores v√°lidos conocidos:', this.validSolicitudValues);
        
        try {
            const mappedData = { ...solicitudData };
            
            if (mappedData.servicioIngenieria && this.fieldMappings.servicioIngenieria[mappedData.servicioIngenieria]) {
                const valorOriginal = mappedData.servicioIngenieria;
                mappedData.servicioIngenieria = this.fieldMappings.servicioIngenieria[mappedData.servicioIngenieria];
                console.log(`üó∫Ô∏è √ÅREA MAPEADA: ${valorOriginal} ‚Üí ${mappedData.servicioIngenieria}`);
            }
            
            if (mappedData.tipoServicio && this.fieldMappings.tipoServicio[mappedData.tipoServicio]) {
                const valorOriginal = mappedData.tipoServicio;
                mappedData.tipoServicio = this.fieldMappings.tipoServicio[mappedData.tipoServicio];
                console.log(`üó∫Ô∏è TIPO SERVICIO MAPEADO: ${valorOriginal} ‚Üí ${mappedData.tipoServicio}`);
            }
            
            if (mappedData.prioridad && this.fieldMappings.prioridad[mappedData.prioridad]) {
                const valorOriginal = mappedData.prioridad;
                mappedData.prioridad = this.fieldMappings.prioridad[mappedData.prioridad];
                console.log(`üó∫Ô∏è PRIORIDAD MAPEADA: ${valorOriginal} ‚Üí ${mappedData.prioridad}`);
            }
            
            if (mappedData.servicioIngenieria && 
                this.validSolicitudValues.servicioIngenieria.length > 0 &&
                !this.validSolicitudValues.servicioIngenieria.includes(mappedData.servicioIngenieria)) {
                console.warn(`‚ö†Ô∏è Valor mapeado ${mappedData.servicioIngenieria} no est√° en la lista de valores v√°lidos`);
                console.log('üìã Valores v√°lidos detectados:', this.validSolicitudValues.servicioIngenieria);
                
                const valorSimilar = this.validSolicitudValues.servicioIngenieria.find(v => 
                    v.toLowerCase().includes('biom') && mappedData.servicioIngenieria.toLowerCase().includes('biom') ||
                    v.toLowerCase().includes('mec') && mappedData.servicioIngenieria.toLowerCase().includes('mec') ||
                    v.toLowerCase().includes('infra') && mappedData.servicioIngenieria.toLowerCase().includes('infra')
                );
                
                if (valorSimilar) {
                    console.log(`‚úÖ Usando valor v√°lido similar: ${valorSimilar}`);
                    mappedData.servicioIngenieria = valorSimilar;
                }
            }
            
            const numero = await this.generateAreaSpecificNumber(solicitudData.servicioIngenieria);
            
            const rawData = {
                numero: numero,
                descripcion: mappedData.descripcion || 'Solicitud de mantenimiento',
                estado: 'Pendiente',
                fechaCreacion: new Date().toISOString(),
                servicioIngenieria: mappedData.servicioIngenieria,
                tipoServicio: mappedData.tipoServicio,
                prioridad: mappedData.prioridad,
                equipo: mappedData.equipo,
                ubicacion: mappedData.ubicacion,
                observaciones: mappedData.observaciones,
                solicitante: mappedData.solicitante,
                servicioHospitalario: mappedData.servicioHospitalario,
                emailSolicitante: mappedData.emailSolicitante,
                tiempoRespuestaMaximo: this.calculateMaxResponseTime(mappedData.prioridad || 'Media')
            };
            
            if (!rawData.servicioIngenieria) {
                console.error('‚ùå ERROR CR√çTICO: servicioIngenieria es undefined o null');
                console.error('Datos originales:', solicitudData);
                throw new Error('El √°rea de ingenier√≠a es requerida');
            }
            
            const cleanData = {};
            Object.keys(rawData).forEach(key => {
                if (rawData[key] !== undefined && rawData[key] !== null && rawData[key] !== '') {
                    cleanData[key] = rawData[key];
                }
            });
            
            const data = {
                fields: cleanData
            };
            
            console.log('üìù Datos finales a enviar (con valores mapeados):', JSON.stringify(data, null, 2));
            console.log('üè• √ÅREA FINAL A GUARDAR:', data.fields.servicioIngenieria);
            console.log('üîß TIPO SERVICIO FINAL:', data.fields.tipoServicio);
            
            try {
                const result = await this.makeRequest(this.tables.solicitudes, 'POST', data);
                console.log(`‚úÖ Solicitud creada correctamente: ${numero}`);
                console.log(`üè• √Årea guardada: ${data.fields.servicioIngenieria}`);
                console.log(`üîß Tipo servicio guardado: ${data.fields.tipoServicio}`);
                
                if (result.fields && result.fields.servicioIngenieria) {
                    console.log(`‚úÖ √ÅREA CONFIRMADA EN RESPUESTA: ${result.fields.servicioIngenieria}`);
                } else {
                    console.warn(`‚ö†Ô∏è √ÅREA NO CONFIRMADA EN RESPUESTA`);
                    console.log('Respuesta completa:', result);
                }
                
                return result;
                
            } catch (error) {
                if (error.message.includes('422')) {
                    console.error('üö® ERROR 422 - Valores inv√°lidos');
                    console.error('üìã Valores detectados disponibles:', this.validSolicitudValues);
                    console.error('üìù Datos que se intentaron enviar:', data);
                    
                    let mensajeError = 'No se pudo crear la solicitud. ';
                    
                    try {
                        if (error.message.includes('servicioIngenieria')) {
                            mensajeError += `El valor "${mappedData.servicioIngenieria}" no es v√°lido para el √°rea. `;
                            mensajeError += `Valores v√°lidos: ${this.validSolicitudValues.servicioIngenieria.join(', ')}`;
                        } else if (error.message.includes('tipoServicio')) {
                            mensajeError += `El tipo de servicio "${mappedData.tipoServicio}" no es v√°lido. `;
                            mensajeError += `Valores v√°lidos: ${this.validSolicitudValues.tipoServicio.join(', ')}`;
                        } else if (error.message.includes('prioridad')) {
                            mensajeError += `La prioridad "${mappedData.prioridad}" no es v√°lida. `;
                        } else {
                            mensajeError += 'Verifique la configuraci√≥n de campos en Airtable.';
                        }
                    } catch (e) {
                        mensajeError += 'Verifique la configuraci√≥n de campos en Airtable.';
                    }
                    
                    throw new Error(mensajeError);
                }
                
                throw error;
            }
            
        } catch (error) {
            console.error('‚ùå Error creando solicitud:', error);
            throw error;
        }
    }

    calculateMaxResponseTime(prioridad) {
        const tiemposRespuesta = {
            'Cr√≠tica': 2,
            'Alta': 8,
            'Media': 24,
            'Baja': 72,
            'CRITICA': 2,
            'ALTA': 8,
            'MEDIA': 24,
            'BAJA': 72
        };
        
        const horas = tiemposRespuesta[prioridad] || 24;
        const fechaMaxima = new Date();
        fechaMaxima.setHours(fechaMaxima.getHours() + horas);
        
        return fechaMaxima.toISOString();
    }

    // üìä FUNCI√ìN PARA CALCULAR TIEMPO DE RESPUESTA
    calculateResponseTime(solicitud) {
        if (!solicitud.fechaCreacion) return null;
        
        const fechaCreacion = new Date(solicitud.fechaCreacion);
        let fechaFin = new Date();
        
        if (solicitud.fechaCompletado) {
            fechaFin = new Date(solicitud.fechaCompletado);
        } else if (solicitud.estado === 'CANCELADA' || solicitud.estado === 'Cancelada') {
            fechaFin = new Date();
        }
        
        const tiempoMs = fechaFin - fechaCreacion;
        const horas = Math.floor(tiempoMs / (1000 * 60 * 60));
        const minutos = Math.floor((tiempoMs % (1000 * 60 * 60)) / (1000 * 60));
        
        return {
            totalMs: tiempoMs,
            horas: horas,
            minutos: minutos,
            formato: `${horas}h ${minutos}m`,
            diasDecimales: (tiempoMs / (1000 * 60 * 60 * 24)).toFixed(2)
        };
    }

    async createTecnico(tecnicoData) {
        console.log('‚ûï Creando personal de soporte:', tecnicoData.nombre);
        console.log('üîç √Årea recibida:', tecnicoData.area);
        
        const rawData = {
            nombre: tecnicoData.nombre,
            email: tecnicoData.email,
            area: tecnicoData.area,
            tipo: tecnicoData.tipo,
            especialidad: tecnicoData.especialidad || '',
            estado: tecnicoData.estado || 'disponible',
            fechaCreacion: new Date().toISOString()
        };
        
        const safeData = this.prepareSafeData(rawData, 'tecnicos');
        
        const data = {
            fields: safeData
        };
        
        console.log('üìù Creando t√©cnico con √°rea mapeada:', data);
        
        try {
            const result = await this.makeRequest(this.tables.tecnicos, 'POST', data);
            console.log('‚úÖ Personal de soporte creado exitosamente:', result.id, '- √Årea:', safeData.area);
            return result;
        } catch (error) {
            console.error('‚ùå Error creando personal de soporte:', error);
            throw new Error(`Error creando personal: ${error.message}`);
        }
    }

    async updateTecnico(tecnicoId, updateData) {
        console.log('üîÑ Actualizando personal de soporte:', tecnicoId);
        
        const safeData = this.prepareSafeData(updateData, 'tecnicos');
        const data = { fields: safeData };
        
        try {
            const result = await this.makeRequest(`${this.tables.tecnicos}/${tecnicoId}`, 'PATCH', data);
            console.log('‚úÖ Personal de soporte actualizado exitosamente');
            return result;
        } catch (error) {
            console.error('‚ùå Error actualizando personal:', error);
            throw error;
        }
    }

    async assignTechnicianToRequest(solicitudId, tecnicoId, observaciones = '') {
        console.log('üéØ Asignando t√©cnico:', { solicitudId, tecnicoId });
        
        try {
            const [solicitudes, tecnicos] = await Promise.all([
                this.getSolicitudes(),
                this.getTecnicos()
            ]);
            
            const solicitud = solicitudes.find(s => s.id === solicitudId);
            const tecnico = tecnicos.find(t => t.id === tecnicoId);
            
            if (!solicitud) {
                throw new Error('Solicitud no encontrada');
            }
            
            if (!tecnico) {
                throw new Error('T√©cnico no encontrado');
            }
            
            const solicitudArea = solicitud.servicioIngenieria;
            const tecnicoArea = tecnico.area;
            
            console.log('üîç Verificando compatibilidad:', { solicitudArea, tecnicoArea });
            
            const normalizeBiomedArea = (area) => {
                if (!area) return area;
                const lowerArea = area.toLowerCase();
                if (lowerArea.includes('biomed') || lowerArea.includes('biom√©d')) {
                    return 'BIOMEDICA_NORMALIZED';
                }
                return area.toUpperCase();
            };
            
            const normalizedSolicitudArea = normalizeBiomedArea(solicitudArea);
            const normalizedTecnicoArea = normalizeBiomedArea(tecnicoArea);
            
            console.log('üîç √Åreas normalizadas:', { normalizedSolicitudArea, normalizedTecnicoArea });
            
            if (normalizedSolicitudArea !== normalizedTecnicoArea) {
                console.warn('‚ö†Ô∏è Advertencia: √Åreas no coinciden exactamente, pero permitiendo asignaci√≥n');
            }
            
            const fechaAsignacion = new Date().toISOString();
            const tiempoEstimadoRespuesta = this.calculateMaxResponseTime(solicitud.prioridad || 'MEDIA');
            
            await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
                fields: {
                    tecnicoAsignado: tecnico.nombre,
                    estado: this.mapFieldValue('estado', 'ASIGNADA'),
                    fechaAsignacion: fechaAsignacion,
                    observacionesAsignacion: observaciones,
                    tiempoRespuestaMaximo: tiempoEstimadoRespuesta
                }
            });
            
            await this.makeRequest(`${this.tables.tecnicos}/${tecnicoId}`, 'PATCH', {
                fields: {
                    estado: this.mapFieldValue('estado', 'ocupado'),
                    solicitudAsignada: solicitud.numero || solicitudId
                }
            });
            
            console.log(`‚úÖ Asignaci√≥n exitosa: ${tecnico.nombre} ‚Üí ${solicitud.numero}`);
            
            return {
                success: true,
                solicitud: { ...solicitud, tecnicoAsignado: tecnico.nombre, estado: 'ASIGNADA' },
                tecnico: { ...tecnico, estado: 'ocupado' },
                fechaAsignacion: fechaAsignacion,
                tiempoEstimadoRespuesta: tiempoEstimadoRespuesta
            };
            
        } catch (error) {
            console.error('‚ùå Error en asignaci√≥n:', error);
            throw error;
        }
    }

    // üîÑ M√âTODO ORIGINAL: Actualizar estado de solicitud (sin cambio de tipo de servicio)
    async updateRequestStatus(solicitudId, nuevoEstado, observaciones = '') {
        console.log('üîÑ Actualizando estado de solicitud:', { solicitudId, nuevoEstado });
        
        try {
            const solicitudes = await this.getSolicitudes();
            const solicitud = solicitudes.find(s => s.id === solicitudId);
            
            if (!solicitud) {
                throw new Error('Solicitud no encontrada');
            }
            
            console.log('üìã Estado actual:', solicitud.estado);
            console.log('üîÑ Nuevo estado solicitado:', nuevoEstado);
            
            const estadoMapeado = this.mapFieldValue('estado', nuevoEstado);
            console.log('üó∫Ô∏è Estado mapeado:', estadoMapeado);
            
            const updateData = {
                estado: estadoMapeado
            };
            
            if (observaciones) {
                updateData.observaciones = (solicitud.observaciones || '') + '\n[' + new Date().toLocaleString('es-CO') + '] ' + observaciones;
            }
            
            if (nuevoEstado === 'EN_PROCESO' || nuevoEstado === 'EN PROCESO') {
                updateData.fechaInicioTrabajo = new Date().toISOString();
                console.log('üìÖ Registrando fecha de inicio de trabajo');
                
            } else if (nuevoEstado === 'COMPLETADA') {
                const fechaCompletado = new Date();
                updateData.fechaCompletado = fechaCompletado.toISOString();
                
                if (solicitud.fechaCreacion) {
                    const fechaCreacion = new Date(solicitud.fechaCreacion);
                    const tiempoTotalMs = fechaCompletado - fechaCreacion;
                    const horas = Math.floor(tiempoTotalMs / (1000 * 60 * 60));
                    const minutos = Math.floor((tiempoTotalMs % (1000 * 60 * 60)) / (1000 * 60));
                    updateData.tiempoTotalRespuesta = `${horas}h ${minutos}m`;
                    
                    console.log('‚è±Ô∏è Tiempo total calculado:', updateData.tiempoTotalRespuesta);
                }
            }
            
            console.log('üìù Datos a actualizar:', updateData);
            
            try {
                const result = await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
                    fields: updateData
                });
                
                console.log('‚úÖ Estado actualizado exitosamente');
                
                if (nuevoEstado === 'COMPLETADA' && solicitud.tecnicoAsignado) {
                    console.log('üîì Liberando t√©cnico asignado...');
                    await this.liberarTecnicoAsignado(solicitudId);
                }
                
                return { 
                    success: true, 
                    solicitud: { ...solicitud, ...updateData },
                    mensaje: `Estado cambiado a ${nuevoEstado}`
                };
                
            } catch (updateError) {
                console.error('‚ùå Error actualizando estado:', updateError);
                
                if (updateError.message.includes('422')) {
                    console.warn('‚ö†Ô∏è Error 422 detectado, intentando con valores alternativos...');
                    
                    const estadoAlternativas = {
                        'EN_PROCESO': ['En Proceso', 'EN PROCESO', 'en_proceso'],
                        'COMPLETADA': ['Completada', 'completada'],
                        'ASIGNADA': ['Asignada', 'asignada'],
                        'PENDIENTE': ['Pendiente', 'pendiente'],
                        'CANCELADA': ['Cancelada', 'cancelada']
                    };
                    
                    const alternativas = estadoAlternativas[nuevoEstado] || [];
                    
                    for (const estadoAlt of alternativas) {
                        try {
                            console.log(`üîÑ Intentando con estado alternativo: ${estadoAlt}`);
                            updateData.estado = estadoAlt;
                            
                            const result = await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
                                fields: updateData
                            });
                            
                            console.log(`‚úÖ Estado actualizado con valor alternativo: ${estadoAlt}`);
                            
                            if (nuevoEstado === 'COMPLETADA' && solicitud.tecnicoAsignado) {
                                await this.liberarTecnicoAsignado(solicitudId);
                            }
                            
                            return { 
                                success: true, 
                                solicitud: { ...solicitud, ...updateData },
                                mensaje: `Estado cambiado a ${nuevoEstado} (usando ${estadoAlt})`
                            };
                            
                        } catch (altError) {
                            console.warn(`‚ùå Fall√≥ con ${estadoAlt}:`, altError.message);
                            continue;
                        }
                    }
                }
                
                throw updateError;
            }
            
        } catch (error) {
            console.error('‚ùå Error en updateRequestStatus:', error);
            throw new Error(`Error actualizando estado: ${error.message}`);
        }
    }

    // üÜï NUEVO M√âTODO: Actualizar estado con cambio de tipo de servicio
    async updateRequestStatusWithServiceType(solicitudId, nuevoEstado, nuevoTipoServicio = null, observaciones = '') {
        console.log('üîÑ Actualizando estado y tipo de servicio de solicitud:', { solicitudId, nuevoEstado, nuevoTipoServicio });
        
        try {
            const solicitudes = await this.getSolicitudes();
            const solicitud = solicitudes.find(s => s.id === solicitudId);
            
            if (!solicitud) {
                throw new Error('Solicitud no encontrada');
            }
            
            console.log('üìã Estado actual:', solicitud.estado);
            console.log('üî® Tipo de servicio actual:', solicitud.tipoServicio);
            console.log('üîÑ Nuevo estado solicitado:', nuevoEstado);
            if (nuevoTipoServicio) {
                console.log('üî® Nuevo tipo de servicio solicitado:', nuevoTipoServicio);
            }
            
            const estadoMapeado = this.mapFieldValue('estado', nuevoEstado);
            console.log('üó∫Ô∏è Estado mapeado:', estadoMapeado);
            
            const updateData = {
                estado: estadoMapeado
            };
            
            // Si se proporciona un nuevo tipo de servicio, mapearlo y agregarlo
            if (nuevoTipoServicio) {
                const tipoServicioMapeado = this.mapFieldValue('tipoServicio', nuevoTipoServicio);
                updateData.tipoServicio = tipoServicioMapeado;
                console.log('üó∫Ô∏è Tipo de servicio mapeado:', tipoServicioMapeado);
                
                // Agregar una observaci√≥n indicando el cambio de tipo de servicio
                const tipoAnterior = solicitud.tipoServicio || 'No especificado';
                const cambioTipoMsg = `\n[${new Date().toLocaleString('es-CO')}] Tipo de servicio actualizado de "${tipoAnterior}" a "${nuevoTipoServicio}"`;
                observaciones = observaciones ? observaciones + cambioTipoMsg : cambioTipoMsg;
            }
            
            if (observaciones) {
                updateData.observaciones = (solicitud.observaciones || '') + '\n[' + new Date().toLocaleString('es-CO') + '] ' + observaciones;
            }
            
            if (nuevoEstado === 'EN_PROCESO' || nuevoEstado === 'EN PROCESO') {
                updateData.fechaInicioTrabajo = new Date().toISOString();
                console.log('üìÖ Registrando fecha de inicio de trabajo');
                
            } else if (nuevoEstado === 'COMPLETADA') {
                const fechaCompletado = new Date();
                updateData.fechaCompletado = fechaCompletado.toISOString();
                
                if (solicitud.fechaCreacion) {
                    const fechaCreacion = new Date(solicitud.fechaCreacion);
                    const tiempoTotalMs = fechaCompletado - fechaCreacion;
                    const horas = Math.floor(tiempoTotalMs / (1000 * 60 * 60));
                    const minutos = Math.floor((tiempoTotalMs % (1000 * 60 * 60)) / (1000 * 60));
                    updateData.tiempoTotalRespuesta = `${horas}h ${minutos}m`;
                    
                    console.log('‚è±Ô∏è Tiempo total calculado:', updateData.tiempoTotalRespuesta);
                }
                
                // Si se detect√≥ que era error de usuario, registrarlo
                if (nuevoTipoServicio === 'ERROR_USUARIO') {
                    console.log('‚ö†Ô∏è Solicitud marcada como ERROR DE USUARIO');
                }
            }
            
            console.log('üìù Datos a actualizar:', updateData);
            
            try {
                const result = await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
                    fields: updateData
                });
                
                console.log('‚úÖ Estado y tipo de servicio actualizados exitosamente');
                
                if (nuevoEstado === 'COMPLETADA' && solicitud.tecnicoAsignado) {
                    console.log('üîì Liberando t√©cnico asignado...');
                    await this.liberarTecnicoAsignado(solicitudId);
                }
                
                return { 
                    success: true, 
                    solicitud: { ...solicitud, ...updateData },
                    mensaje: `Estado cambiado a ${nuevoEstado}${nuevoTipoServicio ? ` y tipo de servicio a ${nuevoTipoServicio}` : ''}`
                };
                
            } catch (updateError) {
                console.error('‚ùå Error actualizando:', updateError);
                
                if (updateError.message.includes('422')) {
                    console.warn('‚ö†Ô∏è Error 422 detectado, intentando con valores alternativos...');
                    
                    const estadoAlternativas = {
                        'EN_PROCESO': ['En Proceso', 'EN PROCESO', 'en_proceso'],
                        'COMPLETADA': ['Completada', 'completada'],
                        'ASIGNADA': ['Asignada', 'asignada'],
                        'PENDIENTE': ['Pendiente', 'pendiente'],
                        'CANCELADA': ['Cancelada', 'cancelada']
                    };
                    
                    const alternativas = estadoAlternativas[nuevoEstado] || [];
                    
                    for (const estadoAlt of alternativas) {
                        try {
                            console.log(`üîÑ Intentando con estado alternativo: ${estadoAlt}`);
                            updateData.estado = estadoAlt;
                            
                            const result = await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
                                fields: updateData
                            });
                            
                            console.log(`‚úÖ Actualizado con valor alternativo: ${estadoAlt}`);
                            
                            if (nuevoEstado === 'COMPLETADA' && solicitud.tecnicoAsignado) {
                                await this.liberarTecnicoAsignado(solicitudId);
                            }
                            
                            return { 
                                success: true, 
                                solicitud: { ...solicitud, ...updateData },
                                mensaje: `Estado cambiado a ${nuevoEstado}${nuevoTipoServicio ? ` y tipo de servicio a ${nuevoTipoServicio}` : ''}`
                            };
                            
                        } catch (altError) {
                            console.warn(`‚ùå Fall√≥ con ${estadoAlt}:`, altError.message);
                            continue;
                        }
                    }
                }
                
                throw updateError;
            }
            
        } catch (error) {
            console.error('‚ùå Error en updateRequestStatusWithServiceType:', error);
            throw new Error(`Error actualizando: ${error.message}`);
        }
    }
// üîÑ M√âTODO: Actualizar √°rea de una solicitud (redirecci√≥n)
async updateRequestArea(solicitudId, nuevaArea, motivo, areaAnterior = '') {
    console.log('üîÑ Actualizando √°rea de solicitud:', { solicitudId, nuevaArea, motivo });
    
    try {
        const solicitudes = await this.getSolicitudes();
        const solicitud = solicitudes.find(s => s.id === solicitudId);
        
        if (!solicitud) {
            throw new Error('Solicitud no encontrada');
        }
        
        console.log('üìã Solicitud actual:', solicitud);
        console.log('üè• √Årea actual:', solicitud.servicioIngenieria);
        console.log('üîÑ Nueva √°rea solicitada:', nuevaArea);
        
        // Mapear el √°rea nueva
        const areaMapeada = this.mapFieldValue('servicioIngenieria', nuevaArea);
        console.log('üó∫Ô∏è √Årea mapeada:', areaMapeada);
        
        // Generar nuevo n√∫mero para el √°rea
        const nuevoNumero = await this.generateAreaSpecificNumber(nuevaArea);
        console.log('üìã Nuevo n√∫mero generado:', nuevoNumero);
        
        // Preparar datos de actualizaci√≥n
        const updateData = {
            servicioIngenieria: areaMapeada,
            numero: nuevoNumero,
            estado: 'PENDIENTE', // Resetear a pendiente
            tecnicoAsignado: '', // Limpiar asignaci√≥n
            fechaAsignacion: null,
            observacionesAsignacion: ''
        };
        
        // Agregar al historial de observaciones
        const fechaActual = new Date().toLocaleString('es-CO');
        const observacionRedirecci√≥n = `[${fechaActual}] REDIRECCI√ìN DE √ÅREA:\n` +
            `- √Årea anterior: ${areaAnterior || solicitud.servicioIngenieria}\n` +
            `- Nueva √°rea: ${nuevaArea}\n` +
            `- Motivo: ${motivo}\n` +
            `- N√∫mero anterior: ${solicitud.numero}\n` +
            `- Nuevo n√∫mero: ${nuevoNumero}`;
        
        updateData.observaciones = (solicitud.observaciones || '') + '\n\n' + observacionRedirecci√≥n;
        
        console.log('üìù Datos a actualizar:', updateData);
        
        // Hacer la actualizaci√≥n
        const result = await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
            fields: updateData
        });
        
        console.log('‚úÖ √Årea actualizada exitosamente');
        
        return {
            success: true,
            solicitud: { ...solicitud, ...updateData },
            nuevoNumero: nuevoNumero,
            areaAnterior: solicitud.servicioIngenieria,
            nuevaArea: nuevaArea,
            mensaje: `Solicitud redirigida de ${solicitud.servicioIngenieria} a ${nuevaArea}`
        };
        
    } catch (error) {
        console.error('‚ùå Error actualizando √°rea:', error);
        throw new Error(`Error al redirigir solicitud: ${error.message}`);
    }
}
    // üîì M√âTODO: Liberar t√©cnico asignado
    // üîì M√âTODO: Liberar t√©cnico asignado
async liberarTecnicoAsignado(solicitudId) {
    console.log('üîì Liberando t√©cnico asignado para solicitud:', solicitudId);
    
    try {
        const solicitudes = await this.getSolicitudes();
        const solicitud = solicitudes.find(s => s.id === solicitudId);
        
        if (!solicitud || !solicitud.tecnicoAsignado) {
            console.log('‚ÑπÔ∏è No hay t√©cnico asignado para liberar');
            return { success: true, mensaje: 'No hab√≠a t√©cnico asignado' };
        }
        
        console.log('üë§ T√©cnico a liberar:', solicitud.tecnicoAsignado);
        
        const tecnicos = await this.getTecnicos();
        const tecnico = tecnicos.find(t => t.nombre === solicitud.tecnicoAsignado);
        
        if (tecnico) {
            console.log('üîÑ Actualizando estado del t√©cnico a disponible...');
            
            try {
                await this.makeRequest(`${this.tables.tecnicos}/${tecnico.id}`, 'PATCH', {
                    fields: {
                        estado: 'disponible',
                        solicitudAsignada: ''
                    }
                });
                
                console.log(`‚úÖ T√©cnico ${tecnico.nombre} liberado exitosamente`);
                
            } catch (tecnicoError) {
                console.error('‚ùå Error actualizando t√©cnico:', tecnicoError);
            }
        } else {
            console.warn('‚ö†Ô∏è No se encontr√≥ el t√©cnico en la base de datos');
        }
        
        // üî¥ CAMBIO IMPORTANTE: NO borrar el t√©cnico de la solicitud si est√° COMPLETADA
        const estadoUpper = (solicitud.estado || '').toUpperCase();
        if (estadoUpper !== 'COMPLETADA') {
            try {
                await this.makeRequest(`${this.tables.solicitudes}/${solicitudId}`, 'PATCH', {
                    fields: {
                        tecnicoAsignado: ''
                    }
                });
                console.log('‚úÖ T√©cnico removido de la solicitud');
            } catch (solicitudError) {
                console.error('‚ùå Error actualizando solicitud:', solicitudError);
            }
        } else {
            console.log('‚úÖ Manteniendo nombre del t√©cnico en solicitud completada');
        }
        
        return { 
            success: true, 
            mensaje: `T√©cnico ${solicitud.tecnicoAsignado} liberado`,
            tecnico: tecnico
        };
        
    } catch (error) {
        console.error('‚ùå Error liberando t√©cnico:', error);
        return { 
            success: false, 
            mensaje: 'Error liberando t√©cnico',
            error: error.message 
        };
    }
}

    async updateSolicitudAcceso(requestId, updateData) {
        const cleanData = {};
        Object.keys(updateData).forEach(key => {
            const value = updateData[key];
            if (typeof value === 'string') {
                cleanData[key] = this.cleanFieldValue(value);
                console.log(`üìù Campo ${key} limpiado: "${updateData[key]}" ‚Üí "${cleanData[key]}"`);
            } else {
                cleanData[key] = value;
            }
        });
        
        const data = { fields: cleanData };
        return await this.makeRequest(`${this.tables.solicitudesAcceso}/${requestId}`, 'PATCH', data);
    }

    async autoAssignPendingRequests() {
        console.log('ü§ñ Iniciando auto-asignaci√≥n de solicitudes pendientes...');
        
        try {
            const [solicitudes, tecnicos] = await Promise.all([
                this.getSolicitudes(),
                this.getTecnicos()
            ]);
            
            const solicitudesPendientes = solicitudes.filter(s => 
                s.estado === 'PENDIENTE' || s.estado === 'Pendiente' || !s.tecnicoAsignado
            );
            
            const tecnicosDisponibles = tecnicos.filter(t => t.estado === 'disponible');
            
            let asignadas = 0;
            let fallidas = 0;
            let sinTecnicos = 0;
            const detalles = [];
            
            for (const solicitud of solicitudesPendientes) {
                try {
                    const normalizeBiomedArea = (area) => {
                        if (!area) return area;
                        const lowerArea = area.toLowerCase();
                        if (lowerArea.includes('biomed') || lowerArea.includes('biom√©d')) {
                            return 'BIOMEDICA_NORMALIZED';
                        }
                        return area.toUpperCase();
                    };
                    
                    const solicitudAreaNorm = normalizeBiomedArea(solicitud.servicioIngenieria);
                    
                    const tecnicoCompatible = tecnicosDisponibles.find(t => {
                        const tecnicoAreaNorm = normalizeBiomedArea(t.area);
                        return tecnicoAreaNorm === solicitudAreaNorm;
                    });
                    
                    if (!tecnicoCompatible) {
                        sinTecnicos++;
                        console.log(`‚ö†Ô∏è Sin t√©cnico disponible para ${solicitud.numero} (${solicitud.servicioIngenieria})`);
                        continue;
                    }
                    
                    await this.assignTechnicianToRequest(
                        solicitud.id, 
                        tecnicoCompatible.id, 
                        'Asignaci√≥n autom√°tica del sistema'
                    );
                    
                    asignadas++;
                    detalles.push({
                        solicitud: solicitud.numero,
                        tecnico: tecnicoCompatible.nombre,
                        area: solicitud.servicioIngenieria
                    });
                    
                    const tecnicoIndex = tecnicosDisponibles.findIndex(t => t.id === tecnicoCompatible.id);
                    if (tecnicoIndex !== -1) {
                        tecnicosDisponibles.splice(tecnicoIndex, 1);
                    }
                    
                } catch (error) {
                    fallidas++;
                    console.error(`‚ùå Error asignando ${solicitud.numero}:`, error);
                }
            }
            
            return {
                asignadas,
                fallidas,
                sinTecnicos,
                detalles,
                total: solicitudesPendientes.length
            };
            
        } catch (error) {
            console.error('‚ùå Error en auto-asignaci√≥n:', error);
            throw error;
        }
    }

    // üìä M√âTODO: Estad√≠sticas avanzadas
    async getAdvancedStatistics() {
        try {
            const [solicitudes, tecnicos, usuarios] = await Promise.all([
                this.getSolicitudes(),
                this.getTecnicos(),
                this.getUsuarios()
            ]);
            
            const totalSolicitudes = solicitudes.length;
            const pendientes = solicitudes.filter(s => s.estado === 'PENDIENTE' || s.estado === 'Pendiente').length;
            const asignadas = solicitudes.filter(s => s.estado === 'ASIGNADA' || s.estado === 'Asignada').length;
            const enProceso = solicitudes.filter(s => s.estado === 'EN_PROCESO' || s.estado === 'En Proceso').length;
            const completadas = solicitudes.filter(s => s.estado === 'COMPLETADA' || s.estado === 'Completada').length;
            const canceladas = solicitudes.filter(s => s.estado === 'CANCELADA' || s.estado === 'Cancelada').length;
            
            const porcentajeCompletadas = totalSolicitudes > 0 
                ? ((completadas / totalSolicitudes) * 100).toFixed(2) 
                : 0;
            
            const mantenimientosCorrectivos = solicitudes.filter(s => 
                s.tipoServicio === 'MANTENIMIENTO_CORRECTIVO' || 
                s.tipoServicio === 'Mantenimiento Correctivo'
            ).length;
            const porcentajeCorrectivos = totalSolicitudes > 0 
                ? ((mantenimientosCorrectivos / totalSolicitudes) * 100).toFixed(2) 
                : 0;
            
            const erroresUsuario = solicitudes.filter(s => 
                s.tipoServicio === 'ERROR_USUARIO' || 
                s.tipoServicio === 'Error de Usuario' ||
                (s.observaciones && s.observaciones.toLowerCase().includes('error de usuario')) ||
                (s.descripcion && s.descripcion.toLowerCase().includes('error de usuario'))
            ).length;
            const porcentajeErroresUsuario = totalSolicitudes > 0 
                ? ((erroresUsuario / totalSolicitudes) * 100).toFixed(2) 
                : 0;
            
            const tiemposRespuesta = [];
            let totalTiempoRespuestaMs = 0;
            let solicitudesConTiempo = 0;
            
            solicitudes.forEach(solicitud => {
                const tiempoRespuesta = this.calculateResponseTime(solicitud);
                if (tiempoRespuesta) {
                    tiemposRespuesta.push({
                        numero: solicitud.numero,
                        estado: solicitud.estado,
                        tiempoFormato: tiempoRespuesta.formato,
                        horas: tiempoRespuesta.horas,
                        minutos: tiempoRespuesta.minutos,
                        diasDecimales: tiempoRespuesta.diasDecimales
                    });
                    
                    if (solicitud.estado === 'COMPLETADA' || solicitud.estado === 'Completada' || 
                        solicitud.estado === 'CANCELADA' || solicitud.estado === 'Cancelada') {
                        totalTiempoRespuestaMs += tiempoRespuesta.totalMs;
                        solicitudesConTiempo++;
                    }
                }
            });
            
            const promedioTiempoRespuestaMs = solicitudesConTiempo > 0 
                ? totalTiempoRespuestaMs / solicitudesConTiempo 
                : 0;
            const promedioHoras = Math.floor(promedioTiempoRespuestaMs / (1000 * 60 * 60));
            const promedioMinutos = Math.floor((promedioTiempoRespuestaMs % (1000 * 60 * 60)) / (1000 * 60));
            
            tiemposRespuesta.sort((a, b) => b.horas - a.horas);
            
            const estadisticasPorTipo = {};
            this.validSolicitudValues.tipoServicio.forEach(tipo => {
                const solicitudesTipo = solicitudes.filter(s => s.tipoServicio === tipo);
                estadisticasPorTipo[tipo] = {
                    total: solicitudesTipo.length,
                    completadas: solicitudesTipo.filter(s => s.estado === 'COMPLETADA' || s.estado === 'Completada').length,
                    porcentaje: totalSolicitudes > 0 ? ((solicitudesTipo.length / totalSolicitudes) * 100).toFixed(2) : 0
                };
            });
            
            return {
                solicitudes: {
                    total: totalSolicitudes,
                    pendientes: pendientes,
                    asignadas: asignadas,
                    enProceso: enProceso,
                    completadas: completadas,
                    canceladas: canceladas,
                    porArea: {
                        INGENIERIA_BIOMEDICA: solicitudes.filter(s => {
                            const area = s.servicioIngenieria || '';
                            return area === 'INGENIERIA_BIOMEDICA' || 
                                   area === 'Ingenier√≠a Biom√©dica' ||
                                   area.toLowerCase().includes('biomed') || 
                                   area.toLowerCase().includes('biom√©d');
                        }).length,
                        MECANICA: solicitudes.filter(s => {
                            const area = s.servicioIngenieria || '';
                            return area === 'MECANICA' || 
                                   area === 'Mec√°nica' ||
                                   area.toLowerCase().includes('mec');
                        }).length,
                        INFRAESTRUCTURA: solicitudes.filter(s => {
                            const area = s.servicioIngenieria || '';
                            return area === 'INFRAESTRUCTURA' || 
                                   area === 'Infraestructura' ||
                                   area.toLowerCase().includes('infra');
                        }).length
                    },
                    porPrioridad: {
                        CRITICA: solicitudes.filter(s => s.prioridad === 'CRITICA' || s.prioridad === 'Cr√≠tica').length,
                        ALTA: solicitudes.filter(s => s.prioridad === 'ALTA' || s.prioridad === 'Alta').length,
                        MEDIA: solicitudes.filter(s => s.prioridad === 'MEDIA' || s.prioridad === 'Media').length,
                        BAJA: solicitudes.filter(s => s.prioridad === 'BAJA' || s.prioridad === 'Baja').length
                    }
                },
                tecnicos: {
                    total: tecnicos.length,
                    disponibles: tecnicos.filter(t => t.estado === 'disponible').length,
                    ocupados: tecnicos.filter(t => t.estado === 'ocupado').length,
                    inactivos: tecnicos.filter(t => t.estado === 'inactivo').length
                },
                usuarios: {
                    total: usuarios.length,
                    activos: usuarios.filter(u => u.estado === 'ACTIVO' || u.estado === 'Activo').length
                },
                tiemposRespuesta: {
                    promedioRespuesta: `${promedioHoras}h ${promedioMinutos}m`,
                    solicitudesVencidas: solicitudes.filter(s => {
                        if (!s.tiempoRespuestaMaximo || 
                            s.estado === 'COMPLETADA' || s.estado === 'Completada' ||
                            s.estado === 'CANCELADA' || s.estado === 'Cancelada') return false;
                        return new Date() > new Date(s.tiempoRespuestaMaximo);
                    }).length,
                    detalleTiempos: tiemposRespuesta.slice(0, 10),
                    totalConTiempoRegistrado: solicitudesConTiempo
                },
                indicadoresGestion: {
                    porcentajeCompletadas: parseFloat(porcentajeCompletadas),
                    porcentajeMantenimientosCorrectivos: parseFloat(porcentajeCorrectivos),
                    porcentajeErroresUsuario: parseFloat(porcentajeErroresUsuario),
                    efectividad: {
                        solicitudesGestionadas: completadas + canceladas,
                        porcentajeGestion: totalSolicitudes > 0 
                            ? (((completadas + canceladas) / totalSolicitudes) * 100).toFixed(2)
                            : 0
                    }
                },
                estadisticasPorTipo: estadisticasPorTipo,
                timestamp: new Date().toISOString()
            };
            
        } catch (error) {
            console.error('‚ùå Error obteniendo estad√≠sticas:', error);
            throw error;
        }
    }

    async testTecnicosTable() {
        console.log('üß™ Test espec√≠fico de tabla Tecnicos...');
        
        try {
            const result = await this.makeRequest(`${this.tables.tecnicos}?maxRecords=3`);
            
            return {
                success: true,
                records: result.records ? result.records.length : 0,
                sampleData: result.records ? result.records[0] : null
            };
            
        } catch (error) {
            console.error('‚ùå Test de Tecnicos fall√≥:', error);
            
            return {
                success: false,
                error: error.message,
                status: error.message.includes('HTTP') ? error.message.match(/HTTP (\d+)/)?.[1] : null
            };
        }
    }

    async testSolicitudesAccesoTable() {
        console.log('üß™ Test espec√≠fico de tabla SolicitudesAcceso...');
        
        try {
            const result = await this.makeRequest(`${this.tables.solicitudesAcceso}?maxRecords=3`);
            
            console.log('‚úÖ Test SolicitudesAcceso exitoso');
            console.log('üìä Registros encontrados:', result.records ? result.records.length : 0);
            
            if (result.records && result.records.length > 0) {
                console.log('üîç Campos disponibles:', Object.keys(result.records[0].fields));
                console.log('üìã Muestra de datos:', result.records[0]);
            }
            
            return {
                success: true,
                records: result.records ? result.records.length : 0,
                availableFields: result.records && result.records.length > 0 ? Object.keys(result.records[0].fields) : [],
                sampleData: result.records ? result.records[0] : null
            };
            
        } catch (error) {
            console.error('‚ùå Test de SolicitudesAcceso fall√≥:', error);
            
            return {
                success: false,
                error: error.message,
                status: error.message.includes('HTTP') ? error.message.match(/HTTP (\d+)/)?.[1] : null
            };
        }
    }

    getStatus() {
        return {
            isConnected: this.connectionStatus === 'connected',
            useProxy: this.useProxy,
            environment: this.isLocalDevelopment ? 'development' : 'production',
            hostname: this.hostname,
            baseUrl: this.baseUrl,
            tables: this.tables,
            timestamp: new Date().toISOString(),
            version: '10.0-cambio-tipo-servicio',
            validAccessRequestValues: this.validAccessRequestValues,
            validUserValues: this.validUserValues,
            validSolicitudValues: this.validSolicitudValues,
            features: [
                '‚ú® NUEVO: Cambio de tipo de servicio al marcar como completada',
                '‚ú® NUEVO: M√©todo updateRequestStatusWithServiceType agregado',
                '‚ú® NUEVO: Detecci√≥n de errores de usuario al completar',
                'FIX: Cambio de estado mejorado con m√∫ltiples intentos',
                'FIX: Liberaci√≥n de t√©cnico al completar solicitud',
                'NUEVO: Indicadores avanzados de gesti√≥n',
                'NUEVO: Porcentaje de solicitudes completadas',
                'NUEVO: Porcentaje de mantenimientos correctivos',
                'NUEVO: Porcentaje de errores de usuario',
                'NUEVO: C√°lculo de tiempos de respuesta detallados',
                'Sistema completo funcionando con cambio de tipo de servicio'
            ]
        };
    }
}

// üåç Crear instancia global
try {
    console.log('üîß Creando instancia global con cambio de tipo de servicio...');
    window.airtableAPI = new AirtableAPI();
    console.log('‚úÖ window.airtableAPI creado exitosamente (versi√≥n con cambio de tipo de servicio)');
} catch (error) {
    console.error('‚ùå Error creando airtableAPI:', error);
}

// üì° Event listeners
try {
    window.addEventListener('airtableConnectionUpdate', function(event) {
        console.log('üîÑ Estado actualizado:', event.detail);
        
        if (typeof updateConnectionStatus === 'function') {
            const status = event.detail.connected ? 'connected' : 'disconnected';
            const message = event.detail.connected 
                ? '‚úÖ Conectado (con cambio tipo servicio)' 
                : 'Modo Local (con cambio tipo servicio)';
            
            updateConnectionStatus(status, message);
        }
    });
} catch (error) {
    console.warn('‚ö†Ô∏è No se pudo configurar event listener:', error);
}

// üõ†Ô∏è Funci√≥n de diagn√≥stico
try {
    window.debugAirtableConnection = function() {
        if (!window.airtableAPI) {
            console.error('‚ùå window.airtableAPI no est√° disponible');
            return { error: 'airtableAPI no disponible' };
        }
        
        const status = window.airtableAPI.getStatus();
        
        console.log('üîç DIAGN√ìSTICO CON CAMBIO DE TIPO DE SERVICIO');
        console.log('==============================================');
        console.log('üåê Hostname:', status.hostname);
        console.log('üè† Entorno:', status.environment);
        console.log('üõ°Ô∏è Proxy:', status.useProxy ? 'HABILITADO' : 'DESHABILITADO');
        console.log('üì° URL base:', status.baseUrl);
        console.log('üîç Estado:', status.isConnected ? '‚úÖ CONECTADO' : '‚ùå DESCONECTADO');
        console.log('üìã Versi√≥n:', status.version);
        console.log('‚ú® NUEVO: Cambio de tipo de servicio al completar habilitado');
        console.log('üìä Nuevas caracter√≠sticas:', status.features.filter(f => f.startsWith('‚ú®') || f.startsWith('NUEVO') || f.startsWith('FIX')));
        
        return status;
    };
    
    console.log('‚úÖ Funciones de debug creadas exitosamente');
} catch (error) {
    console.error('‚ùå Error creando funciones de debug:', error);
}

console.log('‚úÖ airtable-config.js (CON CAMBIO DE TIPO DE SERVICIO) cargado');
console.log('‚ú® NUEVO: M√©todo updateRequestStatusWithServiceType disponible');
console.log('‚ú® NUEVO: Cambio de tipo de servicio al marcar como completada');
console.log('üìä Para estad√≠sticas avanzadas: window.airtableAPI.getAdvancedStatistics()');
console.log('üõ†Ô∏è Para estado general: debugAirtableConnection()');

// Auto-verificaci√≥n despu√©s de la carga
setTimeout(async () => {
    if (window.airtableAPI) {
        console.log('üîÑ Iniciando detecci√≥n autom√°tica de valores v√°lidos...');
        
        try {
            await window.airtableAPI.detectValidAccessRequestValues();
            await window.airtableAPI.detectValidUserValues();
            
            try {
                await window.airtableAPI.detectValidSolicitudValues();
            } catch (error) {
                console.log('üìã Usando valores por defecto para solicitudes');
            }
            
            const solicitudValues = window.airtableAPI.validSolicitudValues;
            
            console.log('‚úÖ Detecci√≥n completada');
            console.log('üìã Valores de solicitudes disponibles:', {
                √°reas: solicitudValues.servicioIngenieria,
                tipos: solicitudValues.tipoServicio.length,
                prioridades: solicitudValues.prioridad.length,
                estados: solicitudValues.estado.length
            });
            console.log('‚ú® Sistema listo con cambio de tipo de servicio al completar');
            
        } catch (error) {
            console.error('‚ùå Error en detecci√≥n autom√°tica:', error);
        }
    }
}, 3000);