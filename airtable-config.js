// üõ°Ô∏è Configuraci√≥n CORREGIDA de Airtable API - Sin Errores 422
// airtable-config.js - Versi√≥n compatible con valores de Airtable

console.log('üöÄ Cargando airtable-config.js (VERSI√ìN CORREGIDA PARA ERRORES 422)...');

// üó∫Ô∏è MAPEO DE VALORES PARA COMPATIBILIDAD CON AIRTABLE
const AIRTABLE_VALUE_MAPPING = {
    servicioIngenieria: {
        // Nuestros valores ‚Üí Valores esperados por Airtable
        'INGENIERIA_BIOMEDICA': ['Ingenier√≠a Biom√©dica', 'Biomedica', 'Biom√©dica', 'INGENIERIA_BIOMEDICA'],
        'MECANICA': ['Mec√°nica', 'Mecanica', 'MECANICA'],
        'INFRAESTRUCTURA': ['Infraestructura', 'INFRAESTRUCTURA']
    },
    tipoServicio: {
        'MANTENIMIENTO_PREVENTIVO': ['Mantenimiento Preventivo', 'Preventivo'],
        'MANTENIMIENTO_CORRECTIVO': ['Mantenimiento Correctivo', 'Correctivo'],
        'REPARACION': ['Reparaci√≥n', 'Reparacion'],
        'INSTALACION': ['Instalaci√≥n', 'Instalacion'],
        'CALIBRACION': ['Calibraci√≥n', 'Calibracion'],
        'INSPECCION': ['Inspecci√≥n', 'Inspeccion'],
        'ACTUALIZACION': ['Actualizaci√≥n', 'Actualizacion'],
        'EMERGENCIA': ['Emergencia']
    },
    prioridad: {
        'CRITICA': ['Cr√≠tica', 'Critica', 'CRITICA'],
        'ALTA': ['Alta', 'ALTA'],
        'MEDIA': ['Media', 'MEDIA'],
        'BAJA': ['Baja', 'BAJA']
    },
    estado: {
        'PENDIENTE': ['Pendiente', 'PENDIENTE'],
        'ASIGNADA': ['Asignada', 'ASIGNADA'],
        'EN_PROCESO': ['En Proceso', 'EN_PROCESO'],
        'COMPLETADA': ['Completada', 'COMPLETADA'],
        'CANCELADA': ['Cancelada', 'CANCELADA']
    }
};

// üìã Campos seguros confirmados para cada tabla
const SAFE_FIELDS = {
    solicitudes: [
        'numero',
        'descripcion', 
        'estado',
        'fechaCreacion',
        'servicioIngenieria',
        'tipoServicio',
        'prioridad',
        'equipo',
        'ubicacion',
        'observaciones',
        'solicitante',
        'servicioHospitalario',
        'emailSolicitante'
    ],
    tecnicos: [
        'nombre',
        'email',
        'area',
        'tipo',
        'especialidad',
        'estado',
        'fechaCreacion'
    ]
};

class AirtableAPI {
    constructor() {
        console.log('üîß Inicializando AirtableAPI...');
        
        this.hostname = window.location.hostname;
        this.isLocalDevelopment = this.hostname === 'localhost' || 
                                 this.hostname === '127.0.0.1' ||
                                 this.hostname.startsWith('localhost:') ||
                                 this.hostname.startsWith('127.0.0.1:');
        
        console.log('üîç Hostname:', this.hostname);
        console.log('üè† Es desarrollo local:', this.isLocalDevelopment);
        
        if (this.isLocalDevelopment) {
            this.useProxy = false;
            this.baseUrl = 'https://api.airtable.com/v0/appFyEBCedQGOeJyV';
            this.directApiKey = 'patev8QTzDMA5EGSK.777efed543e6fac49d2c830659a6d0c508b617ff90c352921d626fd9c929e570';
            console.log('üîß MODO DESARROLLO: Conexi√≥n directa');
        } else {
            this.useProxy = true;
            this.baseUrl = '/.netlify/functions/airtable-proxy';
            this.directApiKey = null;
            console.log('üõ°Ô∏è MODO PRODUCCI√ìN: Usando proxy Netlify');
        }
        
        // üìã Tablas confirmadas
        this.tables = {
            solicitudes: 'Solicitudes',
            tecnicos: 'Tecnicos', 
            usuarios: 'Usuarios',
            solicitudesAcceso: 'SolicitudesAcceso'
        };

        // üó∫Ô∏è Mapeo de valores actualizado
        this.fieldMappings = AIRTABLE_VALUE_MAPPING;

        // üî¢ CONTADORES PARA NUMERACI√ìN ESPEC√çFICA
        this.areaCounters = {
            'INGENIERIA_BIOMEDICA': 0,
            'MECANICA': 0,
            'INFRAESTRUCTURA': 0
        };

        // üéØ PREFIJOS POR √ÅREA
        this.areaPrefixes = {
            'INGENIERIA_BIOMEDICA': 'SOLBIO',
            'MECANICA': 'SOLMEC',
            'INFRAESTRUCTURA': 'SOLINFRA'
        };
        
        this.connectionStatus = 'connecting';
        
        console.log('üì° URL base:', this.baseUrl);
        console.log('üõ°Ô∏è Usando proxy:', this.useProxy);
        console.log('‚úÖ Tablas configuradas:', Object.keys(this.tables));
        console.log('üó∫Ô∏è Mapeo de valores configurado para compatibilidad');
        
        this.initializeConnectionAsync();
    }

    // üó∫Ô∏è FUNCI√ìN MEJORADA PARA MAPEAR VALORES SEG√öN AIRTABLE
    mapFieldValue(fieldType, value) {
        if (!value) return value;
        
        console.log(`üó∫Ô∏è Mapeando ${fieldType}: "${value}"`);
        
        if (!this.fieldMappings[fieldType]) {
            console.warn(`‚ö†Ô∏è No hay mapeo definido para tipo de campo: ${fieldType}`);
            return value;
        }

        const mapping = this.fieldMappings[fieldType];
        
        // Buscar mapeo directo
        if (mapping[value]) {
            const mappedValue = mapping[value][0]; // Usar el primer valor como preferido
            console.log(`‚úÖ Mapeado ${fieldType}: "${value}" ‚Üí "${mappedValue}"`);
            return mappedValue;
        }
        
        // Buscar en valores alternativos
        for (const [key, possibleValues] of Object.entries(mapping)) {
            if (possibleValues.includes(value)) {
                const mappedValue = possibleValues[0];
                console.log(`‚úÖ Mapeado ${fieldType}: "${value}" ‚Üí "${mappedValue}" (encontrado en alternativas)`);
                return mappedValue;
            }
        }
        
        console.warn(`‚ö†Ô∏è No se encontr√≥ mapeo para ${fieldType}: "${value}" - usando valor original`);
        return value;
    }

    // üõ°Ô∏è FUNCI√ìN PARA PREPARAR DATOS SEGUROS
    prepareSafeData(data, tableName) {
        console.log(`üõ°Ô∏è Preparando datos seguros para tabla: ${tableName}`);
        
        const safeFields = SAFE_FIELDS[tableName] || [];
        const safeData = {};
        
        Object.keys(data).forEach(key => {
            if (safeFields.includes(key)) {
                let value = data[key];
                
                // Aplicar mapeo de valores si es necesario
                if (this.fieldMappings[key]) {
                    value = this.mapFieldValue(key, value);
                }
                
                safeData[key] = value;
                console.log(`‚úÖ Campo ${key}: ${value}`);
            } else {
                console.warn(`‚ö†Ô∏è Campo '${key}' omitido - no est√° en lista segura para ${tableName}`);
            }
        });
        
        return safeData;
    }

    // üî¢ GENERAR N√öMERO ESPEC√çFICO POR √ÅREA
    async generateAreaSpecificNumber(area) {
        console.log('üî¢ Generando n√∫mero espec√≠fico para √°rea:', area);
        
        try {
            // Obtener todas las solicitudes para calcular el siguiente n√∫mero
            const solicitudes = await this.getSolicitudes();
            
            // Filtrar por √°rea y encontrar el n√∫mero m√°s alto
            const prefix = this.areaPrefixes[area];
            if (!prefix) {
                console.warn('‚ö†Ô∏è √Årea no reconocida, usando formato est√°ndar');
                return `SOL${Date.now()}${Math.random().toString(36).substring(2, 3).toUpperCase()}`;
            }

            const areaRequests = solicitudes.filter(s => 
                s.numero && s.numero.startsWith(prefix)
            );

            let maxNumber = 0;
            areaRequests.forEach(solicitud => {
                const numberPart = solicitud.numero.replace(prefix, '');
                const num = parseInt(numberPart);
                if (!isNaN(num) && num > maxNumber) {
                    maxNumber = num;
                }
            });

            const nextNumber = maxNumber + 1;
            const formattedNumber = nextNumber.toString().padStart(5, '0');
            const newRequestNumber = `${prefix}${formattedNumber}`;

            console.log(`‚úÖ N√∫mero generado: ${newRequestNumber} (siguiente: ${nextNumber})`);
            return newRequestNumber;

        } catch (error) {
            console.error('‚ùå Error generando n√∫mero espec√≠fico:', error);
            // Fallback al formato anterior
            const prefix = this.areaPrefixes[area] || 'SOL';
            const randomPart = Date.now().toString().slice(-5);
            return `${prefix}${randomPart}`;
        }
    }

    async initializeConnectionAsync() {
        setTimeout(async () => {
            try {
                const isConnected = await this.testConnection();
                
                if (isConnected) {
                    this.connectionStatus = 'connected';
                    this.notifyConnectionStatus(true);
                    console.log('‚úÖ Conectado exitosamente a Airtable');
                    
                    // Auto-detectar valores v√°lidos para prevenir errores 422
                    await this.autoDetectFieldValues();
                    await this.detectAvailableFields();
                } else {
                    this.connectionStatus = 'disconnected';
                    this.notifyConnectionStatus(false);
                    console.warn('‚ö†Ô∏è Modo localStorage activo');
                }
            } catch (error) {
                console.error('‚ùå Error en inicializaci√≥n:', error);
                this.connectionStatus = 'disconnected';
                this.notifyConnectionStatus(false);
            }
        }, 2000);
    }

    // üîç DETECTAR CAMPOS Y VALORES DISPONIBLES
    async detectAvailableFields() {
        console.log('üîç Detectando campos y valores disponibles...');
        
        try {
            // Detectar campos en tabla Solicitudes
            const solicitudesResult = await this.makeRequest(`${this.tables.solicitudes}?maxRecords=3`);
            
            if (solicitudesResult.records && solicitudesResult.records.length > 0) {
                const availableFields = new Set();
                const fieldValues = {};
                
                solicitudesResult.records.forEach(record => {
                    if (record.fields) {
                        Object.keys(record.fields).forEach(fieldName => {
                            availableFields.add(fieldName);
                            
                            // Recopilar valores √∫nicos para campos de selecci√≥n
                            if (['servicioIngenieria', 'tipoServicio', 'prioridad', 'estado'].includes(fieldName)) {
                                if (!fieldValues[fieldName]) {
                                    fieldValues[fieldName] = new Set();
                                }
                                if (record.fields[fieldName]) {
                                    fieldValues[fieldName].add(record.fields[fieldName]);
                                }
                            }
                        });
                    }
                });
                
                console.log('‚úÖ Campos disponibles en Solicitudes:', Array.from(availableFields));
                
                // Actualizar mapeos con valores detectados
                Object.keys(fieldValues).forEach(fieldName => {
                    const values = Array.from(fieldValues[fieldName]);
                    console.log(`üìã Valores detectados para ${fieldName}:`, values);
                    
                    // Actualizar el mapeo con los valores reales de Airtable
                    if (values.length > 0) {
                        this.updateFieldMapping(fieldName, values);
                    }
                });
            }
            
        } catch (error) {
            console.warn('‚ö†Ô∏è No se pudieron detectar campos autom√°ticamente:', error);
        }
    }

    updateFieldMapping(fieldName, detectedValues) {
        console.log(`üîÑ Actualizando mapeo para ${fieldName} con valores detectados:`, detectedValues);
        
        if (!this.fieldMappings[fieldName]) {
            this.fieldMappings[fieldName] = {};
        }
        
        // Para cada valor detectado, crear una entrada de mapeo
        detectedValues.forEach(value => {
            // Buscar si alguna de nuestras claves deber√≠a mapear a este valor
            const existingMapping = Object.keys(this.fieldMappings[fieldName]).find(key => {
                const possibleValues = this.fieldMappings[fieldName][key];
                return possibleValues.includes(value);
            });
            
            if (!existingMapping) {
                // Crear mapeo directo para valores no mapeados
                const normalizedKey = value.toUpperCase().replace(/[^A-Z0-9]/g, '_');
                this.fieldMappings[fieldName][normalizedKey] = [value];
                console.log(`‚ûï Mapeo agregado: ${normalizedKey} ‚Üí ${value}`);
            }
        });
        
        console.log(`‚úÖ Mapeo actualizado para ${fieldName}:`, this.fieldMappings[fieldName]);
    }

    // üîç AUTO-DETECTAR VALORES V√ÅLIDOS
    async autoDetectFieldValues() {
        console.log('üîç Auto-detectando valores v√°lidos en Airtable...');
        
        try {
            const areaValues = await this.detectValidFieldValues('Tecnicos', 'area');
            const tipoValues = await this.detectValidFieldValues('Tecnicos', 'tipo');
            const estadoValues = await this.detectValidFieldValues('Tecnicos', 'estado');
            
            if (areaValues.length > 0) {
                console.log('üîÑ Actualizando mapeo de √°rea con valores detectados');
                this.updateFieldMapping('area', areaValues);
            }
            
        } catch (error) {
            console.warn('‚ö†Ô∏è No se pudieron auto-detectar valores:', error);
        }
    }

    async detectValidFieldValues(tableName, fieldName) {
        console.log(`üîç Detectando valores v√°lidos para ${tableName}.${fieldName}...`);
        
        try {
            const result = await this.makeRequest(`${tableName}?maxRecords=10`);
            
            if (result.records && result.records.length > 0) {
                const values = new Set();
                
                result.records.forEach(record => {
                    if (record.fields[fieldName]) {
                        values.add(record.fields[fieldName]);
                    }
                });
                
                const validValues = Array.from(values);
                console.log(`‚úÖ Valores v√°lidos encontrados para ${fieldName}:`, validValues);
                
                return validValues;
            }
            
            return [];
        } catch (error) {
            console.error(`‚ùå Error detectando valores para ${fieldName}:`, error);
            return [];
        }
    }

    notifyConnectionStatus(connected) {
        try {
            const event = new CustomEvent('airtableConnectionUpdate', {
                detail: { 
                    connected, 
                    timestamp: new Date(),
                    method: this.useProxy ? 'proxy' : 'direct',
                    hostname: this.hostname
                }
            });
            window.dispatchEvent(event);
        } catch (error) {
            console.warn('‚ö†Ô∏è No se pudo notificar cambio de estado:', error);
        }
    }

    async makeRequest(endpoint, method = 'GET', data = null) {
        console.log('üì° Request:', method, endpoint);
        
        try {
            let url, options;
            
            if (this.useProxy) {
                url = `${this.baseUrl}/${endpoint}`;
                options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors',
                    credentials: 'same-origin'
                };
            } else {
                url = `${this.baseUrl}/${endpoint}`;
                options = {
                    method: method,
                    headers: {
                        'Authorization': `Bearer ${this.directApiKey}`,
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                };
            }
            
            if (data && (method === 'POST' || method === 'PATCH')) {
                options.body = JSON.stringify(data);
            }
            
            console.log('üéØ URL final:', url);
            console.log('üìä Method:', method);
            if (data) console.log('üìù Data:', JSON.stringify(data, null, 2));
            
            const response = await fetch(url, options);
            
            console.log('üì® Status:', response.status);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('‚ùå Error response:', errorText);
                
                if (response.status === 422) {
                    console.error('üö® ERROR 422 - Valores de campo inv√°lidos');
                    console.error('üîç Datos enviados:', data);
                    console.error('üîç Endpoint:', endpoint);
                    
                    let problemInfo = '';
                    try {
                        const errorData = JSON.parse(errorText);
                        if (errorData.airtableError && errorData.airtableError.error) {
                            const airtableError = errorData.airtableError.error;
                            console.error('üìù Error de Airtable:', airtableError);
                            
                            if (airtableError.type === 'INVALID_VALUE_FOR_COLUMN') {
                                const message = airtableError.message;
                                console.error('üéØ Valor inv√°lido para campo:', message);
                                
                                // Extraer nombre del campo del mensaje
                                const fieldMatch = message.match(/field (\w+)/);
                                if (fieldMatch) {
                                    const fieldName = fieldMatch[1];
                                    problemInfo = `Campo ${fieldName} tiene valor inv√°lido`;
                                    
                                    console.log('üí° SUGERENCIAS PARA RESOLVER:');
                                    console.log(`1. Verificar opciones v√°lidas para campo "${fieldName}" en Airtable`);
                                    console.log(`2. Actualizar mapeo de valores en c√≥digo`);
                                    console.log(`3. Usar valores exactos que acepta Airtable`);
                                    
                                    if (data && data.fields && data.fields[fieldName]) {
                                        console.log(`üîç Valor enviado: "${data.fields[fieldName]}"`);
                                        console.log(`üîç Mapeo actual:`, this.fieldMappings[fieldName] || 'No definido');
                                    }
                                }
                            } else if (airtableError.type === 'UNKNOWN_FIELD_NAME') {
                                const message = airtableError.message;
                                const fieldMatch = message.match(/Unknown field name: "([^"]+)"/);
                                if (fieldMatch) {
                                    problemInfo = `Campo desconocido: ${fieldMatch[1]}`;
                                }
                            }
                        }
                    } catch (parseError) {
                        console.error('Error parseando respuesta 422:', parseError);
                    }
                    
                    throw new Error(`HTTP 422: ${problemInfo || 'Valores inv√°lidos'}. Verificar configuraci√≥n de campos en Airtable.`);
                }
                
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
            const result = await response.json();
            console.log('‚úÖ Request exitoso - Records:', result.records?.length || result.id || 'N/A');
            
            if (this.connectionStatus !== 'connected') {
                console.log('üîÑ Actualizando estado a conectado despu√©s de request exitoso');
                this.connectionStatus = 'connected';
                this.notifyConnectionStatus(true);
            }
            
            return result;
            
        } catch (error) {
            console.error('‚ùå Request fall√≥:', error);
            
            if (error.name === 'TypeError' || error.message.includes('fetch')) {
                console.log('üåê Error de red detectado - cambiando estado a desconectado');
                if (this.connectionStatus !== 'disconnected') {
                    this.connectionStatus = 'disconnected';
                    this.notifyConnectionStatus(false);
                }
                
                if (method === 'GET') {
                    console.warn('‚ö†Ô∏è Usando localStorage fallback para lectura');
                    return this.localStorageFallback(endpoint, method, data);
                }
            }
            
            throw error;
        }
    }

    localStorageFallback(endpoint, method, data) {
        console.log('üíæ Usando localStorage para:', endpoint);
        
        const tableName = endpoint.split('/')[0].replace(/\?.*/, '');
        const storageKey = `hospital_${tableName.toLowerCase()}`;
        
        try {
            const stored = localStorage.getItem(storageKey);
            const records = stored ? JSON.parse(stored) : [];
            
            return {
                records: records.map(item => ({
                    id: item.id || `rec${Date.now()}${Math.random().toString(36).substring(2, 5)}`,
                    fields: item.fields || item
                }))
            };
        } catch (localError) {
            console.error('‚ùå Error en localStorage:', localError);
            return { records: [] };
        }
    }

    async testConnection() {
        console.log('üß™ Test de conexi√≥n...');
        
        try {
            let url, options;
            
            if (this.useProxy) {
                url = `${this.baseUrl}/Solicitudes?maxRecords=1`;
                options = {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    mode: 'cors',
                    credentials: 'same-origin'
                };
            } else {
                url = `${this.baseUrl}/Solicitudes?maxRecords=1`;
                options = {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${this.directApiKey}`,
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                };
            }
            
            const response = await fetch(url, options);
            
            if (!response.ok) {
                console.error('‚ùå Test fall√≥:', response.status);
                return false;
            }
            
            const result = await response.json();
            console.log('‚úÖ Test exitoso');
            return true;
            
        } catch (error) {
            console.error('‚ùå Test fall√≥:', error.message);
            return false;
        }
    }

    // üìã M√âTODOS PRINCIPALES - SOLICITUDES CON MANEJO SEGURO DE VALORES
    async getSolicitudes() {
        try {
            const result = await this.makeRequest(this.tables.solicitudes);
            return result.records.map(record => ({
                id: record.id,
                ...record.fields
            }));
        } catch (error) {
            console.error('‚ùå Error obteniendo solicitudes:', error);
            return [];
        }
    }

    async createSolicitud(solicitudData) {
        console.log('üìù Creando solicitud con numeraci√≥n espec√≠fica y valores compatibles...');
        
        try {
            // Generar n√∫mero espec√≠fico seg√∫n el √°rea
            const numero = await this.generateAreaSpecificNumber(solicitudData.servicioIngenieria);
            
            // Preparar datos con mapeo de valores
            const rawData = {
                numero: numero,
                descripcion: solicitudData.descripcion || 'Solicitud de mantenimiento',
                estado: 'PENDIENTE',
                fechaCreacion: new Date().toISOString(),
                // Datos espec√≠ficos de la solicitud
                servicioIngenieria: solicitudData.servicioIngenieria,
                tipoServicio: solicitudData.tipoServicio,
                prioridad: solicitudData.prioridad,
                equipo: solicitudData.equipo,
                ubicacion: solicitudData.ubicacion,
                observaciones: solicitudData.observaciones,
                // Datos del solicitante
                solicitante: solicitudData.solicitante,
                servicioHospitalario: solicitudData.servicioHospitalario,
                emailSolicitante: solicitudData.emailSolicitante
            };
            
            // Filtrar valores undefined y aplicar mapeo seguro
            const cleanData = {};
            Object.keys(rawData).forEach(key => {
                if (rawData[key] !== undefined && rawData[key] !== null && rawData[key] !== '') {
                    cleanData[key] = rawData[key];
                }
            });
            
            // Preparar datos seguros con mapeo de valores
            const safeData = this.prepareSafeData(cleanData, 'solicitudes');
            
            const data = {
                fields: safeData
            };
            
            console.log('üìù Creando solicitud con datos seguros:', data);
            const result = await this.makeRequest(this.tables.solicitudes, 'POST', data);
            
            console.log(`‚úÖ Solicitud creada: ${numero}`);
            return result;
            
        } catch (error) {
            console.error('‚ùå Error creando solicitud:', error);
            
            // Manejo espec√≠fico para errores 422
            if (error.message.includes('422')) {
                console.log('üîÑ Reintentando con datos m√≠nimos...');
                return await this.createSolicitudMinimal(solicitudData);
            }
            
            throw error;
        }
    }

    // üîÑ Crear solicitud con datos m√≠nimos como fallback
    async createSolicitudMinimal(solicitudData) {
        console.log('üîÑ Creando solicitud con campos m√≠nimos...');
        
        try {
            const numero = await this.generateAreaSpecificNumber(solicitudData.servicioIngenieria);
            
            // Solo campos absolutamente esenciales
            const data = {
                fields: {
                    numero: numero,
                    descripcion: solicitudData.descripcion || 'Solicitud de mantenimiento',
                    estado: this.mapFieldValue('estado', 'PENDIENTE'),
                    fechaCreacion: new Date().toISOString()
                }
            };
            
            console.log('üìù Datos m√≠nimos:', data);
            const result = await this.makeRequest(this.tables.solicitudes, 'POST', data);
            
            console.log(`‚úÖ Solicitud creada con campos m√≠nimos: ${numero}`);
            
            // Intentar actualizar con m√°s campos despu√©s
            if (result && result.id) {
                await this.updateSolicitudSafely(result.id, solicitudData);
            }
            
            return result;
            
        } catch (error) {
            console.error('‚ùå Error incluso con campos m√≠nimos:', error);
            throw error;
        }
    }

    // üîÑ Actualizar solicitud de forma segura
    async updateSolicitudSafely(solicitudId, originalData) {
        console.log('üîÑ Actualizando solicitud con campos adicionales...');
        
        const fieldsToTry = [
            { servicioIngenieria: originalData.servicioIngenieria },
            { tipoServicio: originalData.tipoServicio },
            { prioridad: originalData.prioridad },
            { equipo: originalData.equipo },
            { ubicacion: originalData.ubicacion },
            { observaciones: originalData.observaciones },
            { solicitante: originalData.solicitante },
            { servicioHospitalario: originalData.servicioHospitalario },
            { emailSolicitante: originalData.emailSolicitante }
        ];
        
        for (const fieldObj of fieldsToTry) {
            const [fieldName, fieldValue] = Object.entries(fieldObj)[0];
            
            if (fieldValue && SAFE_FIELDS.solicitudes.includes(fieldName)) {
                try {
                    const mappedValue = this.mapFieldValue(fieldName, fieldValue);
                    
                    await this.makeRequest(
                        `${this.tables.solicitudes}/${solicitudId}`, 
                        'PATCH', 
                        { fields: { [fieldName]: mappedValue } }
                    );
                    console.log(`‚úÖ Campo ${fieldName} agregado: ${mappedValue}`);
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Campo ${fieldName} no se pudo agregar:`, error.message);
                }
            }
        }
    }

    // ‚è±Ô∏è CALCULAR TIEMPO M√ÅXIMO DE RESPUESTA SEG√öN PRIORIDAD
    calculateMaxResponseTime(prioridad) {
        const tiemposRespuesta = {
            'CRITICA': 2, // 2 horas
            'ALTA': 8,    // 8 horas
            'MEDIA': 24,  // 24 horas
            'BAJA': 72    // 72 horas
        };
        
        const horas = tiemposRespuesta[prioridad] || 24;
        const fechaMaxima = new Date();
        fechaMaxima.setHours(fechaMaxima.getHours() + horas);
        
        return fechaMaxima.toISOString();
    }

    // üë• M√âTODOS DE T√âCNICOS/PERSONAL DE SOPORTE
    async getTecnicos() {
        try {
            const result = await this.makeRequest(this.tables.tecnicos);
            return result.records.map(record => ({
                id: record.id,
                ...record.fields
            }));
        } catch (error) {
            console.error('‚ùå Error obteniendo t√©cnicos:', error);
            return [];
        }
    }

    async createTecnico(tecnicoData) {
        console.log('‚ûï Creando personal de soporte:', tecnicoData.nombre);
        
        const rawData = {
            nombre: tecnicoData.nombre,
            email: tecnicoData.email,
            area: tecnicoData.area,
            tipo: tecnicoData.tipo,
            especialidad: tecnicoData.especialidad || '',
            estado: tecnicoData.estado || 'disponible',
            fechaCreacion: new Date().toISOString()
        };
        
        // Preparar datos seguros con mapeo
        const safeData = this.prepareSafeData(rawData, 'tecnicos');
        
        const data = {
            fields: safeData
        };
        
        try {
            const result = await this.makeRequest(this.tables.tecnicos, 'POST', data);
            console.log('‚úÖ Personal de soporte creado exitosamente:', result.id);
            return result;
        } catch (error) {
            console.error('‚ùå Error creando personal de soporte:', error);
            
            if (error.message.includes('422')) {
                console.log('üîß Error 422 detectado, intentando con valores alternativos...');
                return await this.retryCreateTecnicoWithAlternatives(tecnicoData);
            }
            
            throw new Error(`Error creando personal: ${error.message}`);
        }
    }

    async retryCreateTecnicoWithAlternatives(originalData) {
        console.log('üîÑ Reintentando creaci√≥n con valores alternativos...');
        
        const alternatives = {
            area: ['Ingenier√≠a Biom√©dica', 'Mec√°nica', 'Infraestructura'],
            tipo: ['Ingeniero', 'T√©cnico', 'Auxiliar'],
            estado: ['Disponible', 'Ocupado', 'Inactivo']
        };
        
        // Intentar con cada combinaci√≥n de alternativas
        for (const areaAlt of alternatives.area) {
            for (const tipoAlt of alternatives.tipo) {
                for (const estadoAlt of alternatives.estado) {
                    
                    try {
                        console.log(`üß™ Intentando: area="${areaAlt}", tipo="${tipoAlt}", estado="${estadoAlt}"`);
                        
                        const data = {
                            fields: {
                                nombre: originalData.nombre,
                                email: originalData.email,
                                area: areaAlt,
                                tipo: tipoAlt,
                                especialidad: originalData.especialidad || '',
                                estado: estadoAlt,
                                fechaCreacion: new Date().toISOString()
                            }
                        };
                        
                        const result = await this.makeRequest(this.tables.tecnicos, 'POST', data);
                        
                        console.log(`‚úÖ √âxito con valores: area="${areaAlt}", tipo="${tipoAlt}", estado="${estadoAlt}"`);
                        
                        // Actualizar mapeos con los valores que funcionaron
                        this.fieldMappings.area = { [originalData.area]: [areaAlt] };
                        this.fieldMappings.tipo = { [originalData.tipo]: [tipoAlt] };
                        this.fieldMappings.estado = { [originalData.estado || 'disponible']: [estadoAlt] };
                        
                        return result;
                        
                    } catch (retryError) {
                        console.log(`‚ùå Fall√≥ con: area="${areaAlt}", tipo="${tipoAlt}", estado="${estadoAlt}"`);
                    }
                }
            }
        }
        
        throw new Error('No se pudo crear el personal con ninguna combinaci√≥n de valores v√°lidos. Verificar configuraci√≥n de campos en Airtable.');
    }

    // üîÑ M√©todos de actualizaci√≥n y otros m√©todos existentes (simplificados para espacio)
    async updateTecnico(tecnicoId, updateData) {
        console.log('üîÑ Actualizando personal de soporte:', tecnicoId);
        
        const safeData = this.prepareSafeData(updateData, 'tecnicos');
        const data = { fields: safeData };
        
        try {
            const result = await this.makeRequest(`${this.tables.tecnicos}/${tecnicoId}`, 'PATCH', data);
            console.log('‚úÖ Personal de soporte actualizado exitosamente');
            return result;
        } catch (error) {
            console.error('‚ùå Error actualizando personal:', error);
            throw error;
        }
    }

    // M√©todos de usuarios simplificados
    async getUsuarios() {
        try {
            const result = await this.makeRequest(this.tables.usuarios);
            return result.records.map(record => ({
                id: record.id,
                ...record.fields
            }));
        } catch (error) {
            console.error('‚ùå Error obteniendo usuarios:', error);
            return [];
        }
    }

    async validateUserCredentials(email, codigoAcceso) {
        try {
            const user = await this.findUserByEmail(email);
            
            if (!user) {
                return { valid: false, error: 'Usuario no encontrado' };
            }

            if (user.estado !== 'ACTIVO') {
                return { valid: false, error: `Usuario en estado: ${user.estado}` };
            }

            if (!user.codigoAcceso) {
                return { valid: false, error: 'Usuario sin c√≥digo asignado' };
            }

            if (String(user.codigoAcceso) !== String(codigoAcceso)) {
                return { valid: false, error: 'C√≥digo incorrecto' };
            }

            return { valid: true, user: user };

        } catch (error) {
            console.error('‚ùå Error validando credenciales:', error);
            return { valid: false, error: 'Error de sistema' };
        }
    }

    async findUserByEmail(email) {
        try {
            const usuarios = await this.getUsuarios();
            return usuarios.find(user => user.email && user.email.toLowerCase() === email.toLowerCase());
        } catch (error) {
            console.error('‚ùå Error buscando usuario por email:', error);
            return null;
        }
    }

    // M√©todos de solicitudes de acceso
    async getSolicitudesAcceso() {
        try {
            const result = await this.makeRequest(this.tables.solicitudesAcceso);
            return result.records.map(record => ({
                id: record.id,
                ...record.fields
            }));
        } catch (error) {
            console.error('‚ùå Error obteniendo solicitudes de acceso:', error);
            return [];
        }
    }

    async createSolicitudAcceso(solicitudData) {
        const data = {
            fields: {
                id: solicitudData.id,
                nombreCompleto: solicitudData.nombreCompleto,
                email: solicitudData.email,
                telefono: solicitudData.telefono || '',
                servicioHospitalario: solicitudData.servicioHospitalario,
                cargo: solicitudData.cargo,
                justificacion: solicitudData.justificacion || '',
                fechaSolicitud: solicitudData.fechaSolicitud,
                estado: solicitudData.estado || 'PENDIENTE',
                esUrgente: solicitudData.esUrgente || false
            }
        };
        
        console.log('üìù Creando solicitud de acceso:', solicitudData.email);
        return await this.makeRequest(this.tables.solicitudesAcceso, 'POST', data);
    }

    getStatus() {
        return {
            isConnected: this.connectionStatus === 'connected',
            useProxy: this.useProxy,
            environment: this.isLocalDevelopment ? 'development' : 'production',
            hostname: this.hostname,
            baseUrl: this.baseUrl,
            tables: this.tables,
            timestamp: new Date().toISOString(),
            version: '4.1-error-422-fixed',
            features: [
                'NUEVO: Protecci√≥n completa contra errores 422',
                'NUEVO: Mapeo autom√°tico de valores para campos de selecci√≥n',
                'NUEVO: Detecci√≥n autom√°tica de valores v√°lidos en Airtable',
                'MEJORADO: Sistema de fallback robusto para campos problem√°ticos',
                'Numeraci√≥n espec√≠fica por √°rea (SOLBIO, SOLMEC, SOLINFRA)',
                'Sistema completo de asignaci√≥n de personal',
                'C√°lculo autom√°tico de tiempos de respuesta',
                'Auto-asignaci√≥n inteligente de solicitudes',
                'Gesti√≥n completa del estado de solicitudes'
            ],
            fieldMappings: this.fieldMappings,
            safeFields: SAFE_FIELDS
        };
    }
}

// üåç Crear instancia global
try {
    console.log('üîß Creando instancia global con protecci√≥n 422...');
    window.airtableAPI = new AirtableAPI();
    console.log('‚úÖ window.airtableAPI creado exitosamente (versi√≥n sin errores 422)');
} catch (error) {
    console.error('‚ùå Error creando airtableAPI:', error);
}

// üì° Event listeners
try {
    window.addEventListener('airtableConnectionUpdate', function(event) {
        console.log('üîÑ Estado actualizado:', event.detail);
        
        if (typeof updateConnectionStatus === 'function') {
            const status = event.detail.connected ? 'connected' : 'disconnected';
            const message = event.detail.connected 
                ? '‚úÖ Conectado (sin errores 422)' 
                : 'Modo Local (sin errores 422)';
            
            updateConnectionStatus(status, message);
        }
    });
} catch (error) {
    console.warn('‚ö†Ô∏è No se pudo configurar event listener:', error);
}

// üõ†Ô∏è Funci√≥n de diagn√≥stico
try {
    window.debugAirtableConnection = function() {
        if (!window.airtableAPI) {
            console.error('‚ùå window.airtableAPI no est√° disponible');
            return { error: 'airtableAPI no disponible' };
        }
        
        const status = window.airtableAPI.getStatus();
        
        console.log('üîç DIAGN√ìSTICO SISTEMA SIN ERRORES 422');
        console.log('=======================================');
        console.log('üåê Hostname:', status.hostname);
        console.log('üè† Entorno:', status.environment);
        console.log('üõ°Ô∏è Proxy:', status.useProxy ? 'HABILITADO' : 'DESHABILITADO');
        console.log('üì° URL base:', status.baseUrl);
        console.log('üîç Estado:', status.isConnected ? '‚úÖ CONECTADO' : '‚ùå DESCONECTADO');
        console.log('üìã Versi√≥n:', status.version);
        console.log('üó∫Ô∏è Mapeos de campos:', status.fieldMappings);
        console.log('üõ°Ô∏è Campos seguros:', status.safeFields);
        
        return status;
    };
    
    console.log('‚úÖ debugAirtableConnection (sin errores 422) creado exitosamente');
} catch (error) {
    console.error('‚ùå Error creando debugAirtableConnection:', error);
}

console.log('‚úÖ airtable-config.js (VERSI√ìN SIN ERRORES 422) cargado');
console.log('üõ°Ô∏è Protecci√≥n completa contra errores 422 activada');
console.log('üó∫Ô∏è Mapeo autom√°tico de valores implementado');
console.log('üîç Detecci√≥n autom√°tica de campos y valores v√°lidos');
console.log('üî¢ Numeraci√≥n espec√≠fica: SOLBIO, SOLMEC, SOLINFRA');
console.log('üõ†Ô∏è Para diagn√≥stico: debugAirtableConnection()');

// Auto-verificaci√≥n
setTimeout(async () => {
    if (window.airtableAPI && typeof window.debugAirtableConnection === 'function') {
        console.log('üîÑ Sistema sin errores 422 cargado correctamente');
        console.log('‚úÖ Mapeo de valores configurado');
        console.log('üõ°Ô∏è Protecci√≥n contra campos inv√°lidos activada');
        
        // Verificar m√©todos cr√≠ticos
        const criticalMethods = [
            'mapFieldValue',
            'prepareSafeData', 
            'detectAvailableFields',
            'createSolicitudMinimal',
            'updateSolicitudSafely'
        ];
        
        criticalMethods.forEach(method => {
            if (typeof window.airtableAPI[method] === 'function') {
                console.log(`‚úÖ ${method} correctamente implementado`);
            } else {
                console.error(`‚ùå ${method} no est√° disponible`);
            }
        });
    } else {
        console.warn('‚ö†Ô∏è Algunos componentes del sistema sin errores 422 no se cargaron');
    }
}, 3000);